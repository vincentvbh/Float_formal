
proc main265969440717567711446760966889247597072697656176794927104471372774028478035345692206491807674184569220649180767418(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2962530055241537@52 >= m0 ] ] ,
        or[ 1014@11 < e1, and[1014@11 = e1, 2570627027084474@52 <= m1 ] ], 
        or[ 1014@11 > e1, and[1014@11 = e1, 2570627027084474@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 590@11 < er, and[590@11 = er, 2570627027084474@52 <= mr ] ], 
        or[ 1038@11 > er, and[1038@11 = er, 1360275714184859@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main266693298318164557146848662978924746172697656176794927104471554101673779007645764592251867358754576459225186735875(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 272206880880764@52 >= m0 ] ] ,
        or[ 1016@11 < e1, and[1016@11 = e1, 802003778311939@52 <= m1 ] ], 
        or[ 1016@11 > e1, and[1016@11 = e1, 802003778311939@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 592@11 < er, and[592@11 = er, 802003778311939@52 <= mr ] ], 
        or[ 1040@11 > er, and[1040@11 = er, 1122685427158777@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main267046983017074477946890294531876200322697656176794927104471614953453886321245799960721758350834579996072175835083(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 880724681953900@52 >= m0 ] ] ,
        or[ 1016@11 < e1, and[1016@11 = e1, 4338850767411147@52 <= m1 ] ], 
        or[ 1016@11 > e1, and[1016@11 = e1, 4338850767411147@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 592@11 < er, and[592@11 = er, 4338850767411147@52 <= mr ] ], 
        or[ 1041@11 > er, and[1041@11 = er, 782241094933696@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main267232046163864426246911091523478101462697656176794927104471612453454926022445818467036437345664581846703643734566(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 855724692350912@52 >= m0 ] ] ,
        or[ 1017@11 < e1, and[1017@11 = e1, 1685882607940134@52 <= m1 ] ], 
        or[ 1017@11 > e1, and[1017@11 = e1, 1685882607940134@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 593@11 < er, and[593@11 = er, 1685882607940134@52 <= mr ] ], 
        or[ 1041@11 > er, and[1041@11 = er, 2861940255123810@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main267408848564605622146932595871758297542697656176794927104471643877927695999845836147276511465254583614727651146525(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1169969420050686@52 >= m0 ] ] ,
        or[ 1017@11 < e1, and[1017@11 = e1, 3453906615352093@52 <= m1 ] ], 
        or[ 1017@11 > e1, and[1017@11 = e1, 3453906615352093@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 593@11 < er, and[593@11 = er, 3453906615352093@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 508775455772922@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main267549719435796518346951460823254340512697656176794927104471715472437335667545850234363630554874585023436363055487(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1885914516447363@52 >= m0 ] ] ,
        or[ 1018@11 < e1, and[1018@11 = e1, 359015699890559@52 <= m1 ] ], 
        or[ 1018@11 > e1, and[1018@11 = e1, 359015699890559@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 594@11 < er, and[594@11 = er, 359015699890559@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 2395270605377219@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main267638087348914623346963586505991236882697656176794927104471712246736267464445859071154942365374585907115494236537(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1853657505765332@52 >= m0 ] ] ,
        or[ 1018@11 < e1, and[1018@11 = e1, 1242694831071609@52 <= m1 ] ], 
        or[ 1018@11 > e1, and[1018@11 = e1, 1242694831071609@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 594@11 < er, and[594@11 = er, 1242694831071609@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 3607838879066856@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main267726433627558874246964623822631666912697656176794927104471634578217990808845867905782806790464586790578280679046(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1076972322998776@52 >= m0 ] ] ,
        or[ 1018@11 < e1, and[1018@11 = e1, 2126157617514118@52 <= m1 ] ], 
        or[ 1018@11 > e1, and[1018@11 = e1, 2126157617514118@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 594@11 < er, and[594@11 = er, 2126157617514118@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 3711570543109859@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main267814754945541813546975265048149550332697656176794927104471649072448735332645876737914605084394587673791460508439(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1221914630444014@52 >= m0 ] ] ,
        or[ 1018@11 < e1, and[1018@11 = e1, 3009370797343511@52 <= m1 ] ], 
        or[ 1018@11 > e1, and[1018@11 = e1, 3009370797343511@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 594@11 < er, and[594@11 = er, 3009370797343511@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 272093467527705@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main267903047977615738546991506176345496422697656176794927104471763098065860487245885567217812476894588556721781247689(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2362170801695560@52 >= m0 ] ] ,
        or[ 1018@11 < e1, and[1018@11 = e1, 3892301118082761@52 <= m1 ] ], 
        or[ 1018@11 > e1, and[1018@11 = e1, 3892301118082761@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 594@11 < er, and[594@11 = er, 3892301118082761@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 1896206287122314@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main267977743614071203647002341649306076112697656176794927104471802974056799261845893036781458023404589303678145802340(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2760930711083306@52 >= m0 ] ] ,
        or[ 1019@11 < e1, and[1019@11 = e1, 135657855266916@52 <= m1 ] ], 
        or[ 1019@11 > e1, and[1019@11 = e1, 135657855266916@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 595@11 < er, and[595@11 = er, 135657855266916@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 2979753583180283@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268021856858520071747004123268077675852697656176794927104471755689295252741245897448105902910214589744810590291021(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2288083095618100@52 >= m0 ] ] ,
        or[ 1019@11 < e1, and[1019@11 = e1, 576790299755597@52 <= m1 ] ], 
        or[ 1019@11 > e1, and[1019@11 = e1, 576790299755597@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 595@11 < er, and[595@11 = er, 576790299755597@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 3157915460340257@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268065950975588008947010337167161448672697656176794927104471752135058648170645901857517609703934590185751760970393(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2252540729572394@52 >= m0 ] ] ,
        or[ 1019@11 < e1, and[1019@11 = e1, 1017731470434969@52 <= m1 ] ], 
        or[ 1019@11 > e1, and[1019@11 = e1, 1017731470434969@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 595@11 < er, and[595@11 = er, 1017731470434969@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 3779305368717539@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268110024305156429847019870824516637962697656176794927104471791510141312969845906264850566546024590626485056654602(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2646291556220386@52 >= m0 ] ] ,
        or[ 1019@11 < e1, and[1019@11 = e1, 1458464766119178@52 <= m1 ] ], 
        or[ 1019@11 > e1, and[1019@11 = e1, 1458464766119178@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 595@11 < er, and[595@11 = er, 1458464766119178@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 229071476865972@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268154075187889386547020044594334202162697656176794927104471744762183258246145910669938839841694591066993883984169(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2178811975673149@52 >= m0 ] ] ,
        or[ 1019@11 < e1, and[1019@11 = e1, 1898973593448745@52 <= m1 ] ], 
        or[ 1019@11 > e1, and[1019@11 = e1, 1898973593448745@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 595@11 < er, and[595@11 = er, 1898973593448745@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 246448458622392@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268198101965296041747011167266419830652697656176794927104471627121736212586845915072616580507214591507261658050721(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1002407505216556@52 >= m0 ] ] ,
        or[ 1019@11 < e1, and[1019@11 = e1, 2339241367515297@52 <= m1 ] ], 
        or[ 1019@11 > e1, and[1019@11 = e1, 2339241367515297@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 595@11 < er, and[595@11 = er, 2339241367515297@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 3862315294555737@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268242102979793110047017458698058999052697656176794927104471632761147400214445919472718030214044591947271803021404(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1058801617092832@52 >= m0 ] ] ,
        or[ 1019@11 < e1, and[1019@11 = e1, 2779251512485980@52 <= m1 ] ], 
        or[ 1019@11 > e1, and[1019@11 = e1, 2779251512485980@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 595@11 < er, and[595@11 = er, 2779251512485980@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 4491458458472577@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268286076574767265247031616480606608442697656176794927104471765508502197512845923870077527629564592387007752762956(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2386275165065816@52 >= m0 ] ] ,
        or[ 1019@11 < e1, and[1019@11 = e1, 3218987462227532@52 <= m1 ] ], 
        or[ 1019@11 > e1, and[1019@11 = e1, 3218987462227532@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 595@11 < er, and[595@11 = er, 3218987462227532@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 1403637085863020@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268330021094637510547040721927183925952697656176794927104471828896327466823345928264529514654094592826452951465409(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3020153417758921@52 >= m0 ] ] ,
        or[ 1019@11 < e1, and[1019@11 = e1, 3658432660929985@52 <= m1 ] ], 
        or[ 1019@11 > e1, and[1019@11 = e1, 3658432660929985@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 595@11 < er, and[595@11 = er, 3658432660929985@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 2314181743594771@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268373934884917510347041833372786701652697656176794927104471802122482957789845932655908542654074593265590854265407(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2752414972668586@52 >= m0 ] ] ,
        or[ 1019@11 < e1, and[1019@11 = e1, 4097570563729983@52 <= m1 ] ], 
        or[ 1019@11 > e1, and[1019@11 = e1, 4097570563729983@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 595@11 < er, and[595@11 = er, 4097570563729983@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 2425326303872341@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268416177041779721147047262852115520102697656176794927104471820998609748274445936880124228875154593688012422887515(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2941176240573432@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 16392504981595@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 16392504981595@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 596@11 < er, and[596@11 = er, 16392504981595@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 2968274236754186@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268438100727944999047058073984763927872697656176794927104471889295204063094945939072492845402944593907249284540294(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3624142183721637@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 235629366634374@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 235629366634374@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 596@11 < er, and[596@11 = er, 235629366634374@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 4049387501594963@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268460006571180976747058867420140576142697656176794927104471860593381624683045941263077169000714594126307716900071(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3337123959337518@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 454687798994151@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 454687798994151@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 596@11 < er, and[596@11 = er, 454687798994151@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 4128731039259790@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268481893746745037747049269142869719952697656176794927104471743950401977702245943451794725406814594345179472540681(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2170694162867710@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 673559554634761@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 673559554634761@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 596@11 < er, and[596@11 = er, 673559554634761@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 3168903312174171@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268503761430597392747052107817162716312697656176794927104471740594328592202245945638563110642314594563856311064231(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2137133429012710@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 892236393158311@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 892236393158311@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 596@11 < er, and[596@11 = er, 892236393158311@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 3452770741473807@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268525608799432104347065717867221622992697656176794927104471848808972362940345947823299994113474594782329999411347(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3219279866720091@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 1110710081505427@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 1110710081505427@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 596@11 < er, and[596@11 = er, 1110710081505427@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 310176119993979@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268547435030708084047068895625004312962697656176794927104471868982854644874745950005923121711444595000592312171144(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3421018689539435@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 1328972394265224@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 1328972394265224@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 596@11 < er, and[596@11 = er, 1328972394265224@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 627951898262976@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268569239302680060647065842602384407492697656176794927104471794976760576010345952186350318909104595218635031890910(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2680957748850791@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 1547015113984990@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 1547015113984990@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 596@11 < er, and[596@11 = er, 1547015113984990@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 322649636272429@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268591020794429518147065807225019163842697656176794927104471769503572603516845954364499493854854595436449949385485(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2426225869125856@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 1764830031479565@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 1764830031479565@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 596@11 < er, and[596@11 = er, 1764830031479565@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 319111899748064@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268612778685895603147068776415545896532697656176794927104471787490369050330845956540288640463354595654028864046335(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2606093833593996@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 1982408946140415@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 1982408946140415@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 596@11 < er, and[596@11 = er, 1982408946140415@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 616030952421333@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268634512157905999647065511251611062582697656176794927104471720565832175108045958713635841503004595871363584150300(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1936848464841768@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 2199743666244380@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 2199743666244380@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 596@11 < er, and[596@11 = er, 2199743666244380@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 289514558937938@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268656220392207770047051558008321338782697656176794927104471590719088325317145960884459271680044596088445927168004(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 638381026343859@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 2416826009262084@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 2416826009262084@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 596@11 < er, and[596@11 = er, 2416826009262084@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 3397789857336054@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268677902571498162647054268547690751992697656176794927104471592201802019011545963052677200719304596305267720071930(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 653208163280803@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 2633647802166010@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 2633647802166010@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 596@11 < er, and[596@11 = er, 2633647802166010@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 3668843794277375@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268699557879455381847070618438243619622697656176794927104471726153539238377445965218207996441224596521820799644122(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1992725535474462@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 2850200881738202@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 2850200881738202@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 596@11 < er, and[596@11 = er, 2850200881738202@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 800233222193642@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268721185500769322747078199934889408352697656176794927104471797801485319218145967380970127835314596738097012783531(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2709204996282869@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 3066477094877611@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 3066477094877611@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 596@11 < er, and[596@11 = er, 3066477094877611@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 1558382886772515@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268742784621172266947078703353430248222697656176794927104471783616363188740045969540882168129734596954088216812973(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2567353774978088@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 3282468298907053@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 3282468298907053@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 596@11 < er, and[596@11 = er, 3282468298907053@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 1608724740856502@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268764354427469538947083082209658352382697656176794927104471813846341251488445971697862797856934597169786279785693(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2869653555605572@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 3498166361879773@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 3498166361879773@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 596@11 < er, and[596@11 = er, 3498166361879773@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 2046610363666918@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268785894107570123047092203406495705882697656176794927104471894500318252105945973851830807915344597385183080791534(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3676193325611747@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 3713563162885614@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 3713563162885614@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 596@11 < er, and[596@11 = er, 3713563162885614@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 2958730047402268@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268807402850517237847092639224759015492697656176794927104471878290879364524045976002705102626824597600270510262682(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3514098936735928@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 3928650592356762@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 3928650592356762@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 596@11 < er, and[596@11 = er, 3928650592356762@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 3002311873733229@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268828879846518868047084149057152930122697656176794927104471769938825839773445978150404702789844597815040470278984(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2430578401488422@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 4143420552373064@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 4143420552373064@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 596@11 < er, and[596@11 = er, 4143420552373064@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 2153295113124692@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268850324286978253047086542263671424682697656176794927104471777484002056105845980294848748728344598029484874872834(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2506030163651746@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 4357864956966914@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 4357864956966914@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 596@11 < er, and[596@11 = er, 4357864956966914@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 2392615764974148@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268868316559271470647101033447103481742697656176794927104471904766955838576845982094075978050104598209407597805010(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3778859701476456@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 34188052528594@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 34188052528594@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 34188052528594@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 3841734108179854@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268879005013530371047106640519901606162697656176794927104471940074812690376645983162921403940144598316292140394014(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 4131938269994454@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 141072595117598@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 141072595117598@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 141072595117598@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 4402441387992296@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268889675980860871847101516608185460652697656176794927104471872113529253002045984230018136990224598423001813699022(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3452325435620708@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 247782268422606@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 247782268422606@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 247782268422606@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 3890050216377745@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268900329059507084047101709984965162792697656176794927104471856459443960957245985295326001611444598529532600161144(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3295784582700260@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 354313054884728@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 354313054884728@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 354313054884728@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 3909387894347959@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268910963848386617947107244184449682822697656176794927104471889957561257229445986358804889564834598635880488956483(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3630765755662982@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 460660943680067@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 460660943680067@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 460660943680067@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 4462807842799962@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268921579947105683047101936100600039102697656176794927104471825779451674330645987420414761471344598742041476147134(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2988984659833994@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 566821930870718@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 566821930870718@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 566821930870718@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 3931999457835590@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268932176955974162647087513671136203402697656176794927104471684961771821360845988480115648319304598848011564831930(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1580807861304296@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 672792019555514@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 672792019555514@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 672792019555514@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 2489756511452020@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268942754476020662447088633628828504722697656176794927104471682326578324544845989537867652969284598953786765296928(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1554455926336136@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 778567220020512@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 778567220020512@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 778567220020512@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 2601752280682152@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268953312109007531147106055498192005192697656176794927104471816084349041452445990593630951656154599059363095165615(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2892033633505212@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 884143549889199@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 884143549889199@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 884143549889199@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 4343939217032199@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268963849457445853947111158565959104422697656176794927104471872483744854028445991647365795488434599164736579548843(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3456027591630972@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 989517034272427@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 989517034272427@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 989517034272427@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 350646366371626@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268974366124610417747109639507214401122697656176794927104471833090705056114445992699032511944814599269903251194481(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3062097193651832@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 1094683705918065@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 1094683705918065@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 1094683705918065@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 198740491901296@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268984861714554648047111058167027068822697656176794927104471841572738269884245993748591506367844599374859150636784(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3146917525789530@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 1199639605360368@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 1199639605360368@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 1199639605360368@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 340606473168066@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main268995335832125515547115695499355445192697656176794927104471899693000915869545994796003263454594599479600326345459(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3728120152249383@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 1304380781069043@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 1304380781069043@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 1304380781069043@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 804339706005703@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269005788082978413647113988568906017552697656176794927104471859137143240269845995841228348744404599584122834874440(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3322561575493386@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 1408903289598024@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 1408903289598024@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 1408903289598024@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 633646661062939@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269016218073592005247105293052741360032697656176794927104471733055712546296745996884227410103564599688422741010356(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2061747268553655@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 1513203195733940@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 1513203195733940@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 1513203195733940@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 4267694671967683@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269026625411283039047105071822719983832697656176794927104471720264880961955245997924961179206944599792496117920694(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1933838952710240@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 1617276572644278@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 1617276572644278@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 1617276572644278@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 4245571669830063@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269037009704221133047113600030568166372697656176794927104471814260923554721645998963390473016344599896339047301634(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2873799378637904@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 1721119502025218@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 1721119502025218@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 1721119502025218@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 594792827277821@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269047370561443527547115025349440692532697656176794927104471822469274250068345999999476195255794599999947619525579(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2955882885591371@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 1824728074249163@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 1824728074249163@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 1824728074249163@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 737324714530437@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269057707592869803847110198805829639452697656176794927104471742887598608454246001033179337883424600103317933788342(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2160066129175230@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 1928098388511926@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 1928098388511926@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 1928098388511926@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 254670353425129@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269068020409316571447108560884746671802697656176794927104471709795367626330646002064460982560184600206446098256018(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1829143819353994@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 2031226552979602@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 2031226552979602@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 2031226552979602@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 90878245128364@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269078308622512119847109787186996183092697656176794927104471716620444935355046003093282302115024600309328230211502(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1897394592444238@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 2134108684935086@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 2134108684935086@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 2134108684935086@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 213508470079493@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269088571845111037247103072830596541502697656176794927104471647745849902887846004119604562006764600411960456200676(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1208648642119566@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 2236740910924260@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 2236740910924260@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 2236740910924260@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 4045672457485830@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269098809690708793547085837407267529352697656176794927104471524644659884387646005143389121782394600514338912178239(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 4481236369305060@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 2339119366901823@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 2339119366901823@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 2339119366901823@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 2322130124584615@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269109021773856288447086856080105441322697656176794927104471524644659884387646006164597436531884600616459743653188(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 4481236369305060@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 2441240198376772@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 2441240198376772@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 2441240198376772@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 2423997408375812@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269119207710074363347106958603780230732697656176794927104471647745849902887846007183191058339374600718319105833937(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1208648642119566@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 2543099560557521@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 2543099560557521@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 2543099560557521@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 4434249775854753@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269129367115868276747113415674738065602697656176794927104471716620444935355046008199131637730714600819913163773071(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1897394592444238@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 2644693618496655@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 2644693618496655@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 2644693618496655@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 576357244267744@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269139499608742142647113586413980980002697656176794927104471709795367626330646009212380925117304600921238092511730(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1829143819353994@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 2746018547235314@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 2746018547235314@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 2746018547235314@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 593431168559184@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269149604807213331247116997504326517712697656176794927104471742887598608454246010222900772236164601022290077223616(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2160066129175230@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 2847070531947200@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 2847070531947200@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 2847070531947200@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 934540203112955@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269159682330826831547124326661158356462697656176794927104471822469274250068346011230653133586194601123065313358619(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2955882885591371@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 2947845768082203@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 2947845768082203@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 2947845768082203@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1667455886296830@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269169731800169575347124470711131938862697656176794927104471814260923554721646012235600067860574601223560006786057(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2873799378637904@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 3048340461509641@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 3048340461509641@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 3048340461509641@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1681860883655070@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269179752836884721847117305968178681462697656176794927104471720264880961955246013237703739375224601323770373937522(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1933838952710240@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 3148550828661106@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 3148550828661106@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 3148550828661106@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 965386588329330@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269189745063685902747119120958591684672697656176794927104471733055712546296746014236926419493314601423692641949331(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2061747268553655@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 3248473096672915@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 3248473096672915@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 3248473096672915@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1146885629629651@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269199708104371426547130837861399305162697656176794927104471859137143240269846015233230488045694601523323048804569(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3322561575493386@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 3348103503528153@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 3348103503528153@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 3348103503528153@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2318575910391700@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269209641583838442547135280998081179062697656176794927104471899693000915869546016226578434747294601622657843474729(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3728120152249383@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 3447438298198313@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 3447438298198313@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 3447438298198313@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2762889578579090@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269219545128097063347130991660559182602697656176794927104471841572738269884246017216932860609374601721693286060937(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3146917525789530@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 3546473740784521@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 3546473740784521@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 3546473740784521@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2333955826379444@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269229418364284444947131062902704189252697656176794927104471833090705056114446018204256479347534601820425647934753(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3062097193651832@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 3645206102658337@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 3645206102658337@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 3645206102658337@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2341080040880109@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269239260920678825347135496570672615322697656176794927104471872483744854028446019188512118785574601918851211878557(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3456027591630972@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 3743631666602141@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 3743631666602141@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 3743631666602141@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2784446837722716@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269249072426713519347131138095294927572697656176794927104471816084349041452446020169662722254974602016966272225497(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2892033633505212@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 3841746726949081@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 3841746726949081@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 3841746726949081@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2348599299953941@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269258852512990870247119402964447570542697656176794927104471682326578324544846021147671349990064602114767134999006(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1554455926336136@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 3939547589722590@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 3939547589722590@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 3939547589722590@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1175086215218238@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269268600811296157347120308483949725862697656176794927104471684961771821360846022122501180518774602212250118051877(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1580807861304296@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 4037030572775461@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 4037030572775461@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 4037030572775461@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1265638165433770@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269278316954611459247134469053910825202697656176794927104471825779451674330646023094115512048964602309411551204896(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2988984659833994@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 4134192005928480@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 4134192005928480@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 4134192005928480@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2681695161543704@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269288000577129471847141498178546385392697656176794927104471889957561257229446024062477763850224602406247776385022(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3630765755662982@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 4231028231108606@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 4231028231108606@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 4231028231108606@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 3384607625099723@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269297651314267280347139085399884027472697656176794927104471856459443960957246025027551477631074602502755147763107(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3295784582700260@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 4327535602486691@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 4327535602486691@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 4327535602486691@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 3143329758863931@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269307268802680086247141469707759832442697656176794927104471872113529253002046025989300318911664602598930031891166(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3452325435620708@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 4423710486614750@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 4423710486614750@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 597@11 < er, and[597@11 = er, 4423710486614750@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 3381760546444428@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269316055198515273747149124400097193462697656176794927104471940074812690376646026867939902430414602686793990243041(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 4131938269994454@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 7974817596129@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 7974817596129@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 7974817596129@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 4147229780180530@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269320830151489883847146465512079217712697656176794927104471904766955838576846027345435199891424602734543519989142(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3778859701476456@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 55724347342230@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 55724347342230@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 55724347342230@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 3881340978382955@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269325587938867423147134320251845881142697656176794927104471777484002056105846027821213937645354602782121393764535(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2506030163651746@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 103302221117623@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 103302221117623@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 103302221117623@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2666814955049298@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269330328381519886047134278311772901802697656176794927104471769938825839773446028295258202891644602829525820289164(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2430578401488422@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 150706647642252@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 150706647642252@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 150706647642252@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2662620947751364@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269335051300972286047146316917155308262697656176794927104471878290879364524046028767550148131644602876755014813164(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3514098936735928@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 197935842166252@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 197935842166252@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 197935842166252@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 3866481485992010@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269339756519409375047148863701371829852697656176794927104471894500318252105946029238071991840544602923807199184054(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3676193325611747@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 244988026537142@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 244988026537142@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 244988026537142@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 4121159907644169@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269344443859682338347141126967166622502697656176794927104471813846341251488446029706806019136874602970680601913687(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2869653555605572@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 291861429266775@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 291861429266775@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 291861429266775@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 3347486487123434@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269349113145315463947138641169345509652697656176794927104471783616363188740046030173734582449434603017373458244943(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2567353774978088@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 338554285598031@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 338554285598031@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 338554285598031@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 3098906705012149@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269353764200512786847140911213432928662697656176794927104471797801485319218146030638840102181724603063884010218172(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2709204996282869@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 385064837571260@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 385064837571260@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 385064837571260@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 3325911113754050@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269358396850164707747133802065285272702697656176794927104471726153539238377446031102105067373814603110210506737381(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1992725535474462@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 431391334090469@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 431391334090469@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 431391334090469@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2614996298988454@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269363010919854585547119652123135591242697656176794927104471592201802019011546031563512036361594603156351203636159(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 653208163280803@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 477532030989247@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 477532030989247@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 477532030989247@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1200002084020308@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269367606235865304247120012799821994612697656176794927104471590719088325317146032023043637433464603202304363743346(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 638381026343859@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 523485191096434@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 523485191096434@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 523485191096434@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1236069752660645@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269372182625185813447135161228835465132697656176794927104471720565832175108046032480682569484384603248068256948438(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1936848464841768@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 569249084301526@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 569249084301526@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 569249084301526@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2750912654007697@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269376739915517641847143419045220350512697656176794927104471787490369050330846032936411602667224603293641160266722(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2606093833593996@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 614821987619810@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 614821987619810@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 614821987619810@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 3576694292496235@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269381277935281384047142073092478747442697656176794927104471769503572603516846033390213579041444603339021357904144(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2426225869125856@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 660202185257232@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 660202185257232@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 660202185257232@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 3442099018335928@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269385796513623161047145714679057281122697656176794927104471794976760576010346033842071413219144603384207141321914(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2680957748850791@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 705387968675002@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 705387968675002@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 705387968675002@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 3806257676189296@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269390295480421052047153877086650209582697656176794927104471868982854644874746034291968093008244603429196809300824(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3421018689539435@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 750377636653912@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 750377636653912@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 750377636653912@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 118898808111646@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269394774666291500047153084377350593462697656176794927104471848808972362940346034739886680053044603473988668005304(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3219279866720091@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 795169495358392@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 795169495358392@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 795169495358392@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 39627878150034@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269399233902595688547141406052257380672697656176794927104471740594328592202246035185810310471894603518581031047189(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2137133429012710@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 839761858400277@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 839761858400277@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 839761858400277@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 3375394996199251@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269403673021445891147142462111867086852697656176794927104471743950401977702246035629722195492154603562972219549215(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2170694162867710@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 884153046902303@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 884153046902303@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 884153046902303@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 3481000957169869@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269408091855711792147154936887330698972697656176794927104471860593381624683046036071605622082254603607160562208225(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3337123959337518@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 928341389561313@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 928341389561313@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 928341389561313@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 224878876160585@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269412490239026778947157064691158658612697656176794927104471889295204063094946036511443953580934603651144395358093(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3624142183721637@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 972325222711181@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 972325222711181@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 972325222711181@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 437659258956549@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269416868005794205747153274439428420152697656176794927104471820998609748274446036949220630323614603694922063032361(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2941176240573432@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1016102890385449@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1016102890385449@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 1016102890385449@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 58634085932703@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269421224991193628047152249263703114012697656176794927104471802122482957789846037384919170265844603738491917026584(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2752414972668586@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1059672744379672@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1059672744379672@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 1059672744379672@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 4459716140772585@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269425561031187008047154484551757052302697656176794927104471828896327466823346037818523169603844603781852316960384(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3020153417758921@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1103033144313472@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1103033144313472@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 1103033144313472@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 179645318795918@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269429875962524890847149049835463481312697656176794927104471765508502197512846038250016303392124603825001630339212(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2386275165065816@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1146182457692300@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1146182457692300@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 1146182457692300@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 4139773316809315@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269434169622752550447132926942087997872697656176794927104471632761147400214446038679382326158084603867938232615808(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1058801617092832@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1189119059968896@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1189119059968896@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 1189119059968896@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2527483979260971@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269438441850216105847132736413016210952697656176794927104471627121736212586846039106605072513624603910660507251362(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1002407505216556@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1231841334604450@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1231841334604450@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 1231841334604450@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2508431072082279@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269442692484068607947148348909284168502697656176794927104471744762183258246146039531668457763834603953166845776383(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2178811975673149@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1274347673129471@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1274347673129471@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 1274347673129471@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 4069680698878034@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269446921364276094547153852984078161372697656176794927104471791510141312969846039954556478512494603995455647851249(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2646291556220386@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1316636475204337@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1316636475204337@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 1316636475204337@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 116488550906825@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269451128331623615947150560337115414112697656176794927104471752135058648170646040375253213264634604037525321326463(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2252540729572394@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1358706148679551@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1358706148679551@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 1358706148679551@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 4290823482002595@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269455313227721229447151654095716883022697656176794927104471755689295252741246040793742823025984604079374282302598(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2288083095618100@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1400555109655686@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1400555109655686@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 1400555109655686@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 4400199342149486@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269459475895009962247155606308943360632697656176794927104471802974056799261846041210009551899264604121000955189926(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2760930711083306@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1442181782543014@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1442181782543014@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 1442181782543014@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 291821037426751@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269463616176767743647153289632075629132697656176794927104471763098065860487246041624037727677404604162403772767740(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2362170801695560@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1483584600120828@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1483584600120828@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 1483584600120828@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 60153350653601@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269467733917115305547139255846063396492697656176794927104471649072448735332646042035811762433594604203581176243359(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1221914630444014@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1524762003596447@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1524762003596447@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 1524762003596447@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 3160374376800833@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269471828961022051147137823130398864232697656176794927104471634578217990808846042445316153108154604244531615310815(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1076972322998776@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1565712442663903@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1565712442663903@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 1565712442663903@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 3017102810347607@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269475901154311892047148865019030689372697656176794927104471712246736267464446042852535482092244604285253548209224(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1853657505765332@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1606434375562312@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1606434375562312@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 1606434375562312@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 4121291673530121@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269479950343669052447149877131555114732697656176794927104471715472437335667546043257454417808284604325745441780828(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1885914516447363@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1646926269133916@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1646926269133916@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 1646926269133916@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 4222502925972657@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269483976376643841647140606726899707662697656176794927104471643877927695999846043660057715287204604366005771528720(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1169969420050686@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1687186598881808@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1687186598881808@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 1687186598881808@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 3295462460431950@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269487979101658393547136763350356552712697656176794927104471612453454926022446044060330216742394604406033021674239(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 855724692350912@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1727213849027327@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1727213849027327@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 1727213849027327@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2911124806116455@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269491958368012373947137584975075387412697656176794927104471614953453886321246044458256852140434604445825685214043(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 880724681953900@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1767006512567131@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1767006512567131@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 1767006512567131@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2993287277999925@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269495914025888653447129531726133521232697656176794927104471554101673779007646044853822639768384604485382263976838(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 272206880880764@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1806563091329926@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1806563091329926@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 1806563091329926@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2187962383813307@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269499845926358948947115247398639476802697656176794927104471372774028478035346045247012686797934604524701268679793(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2962530055241537@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1845882096032881@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1845882096032881@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 1845882096032881@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 759529634408864@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269503753921389430047115571335047136682697656176794927104471372774028478035346045637812189846044604563781218984604(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2962530055241537@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1884962046337692@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1884962046337692@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 1884962046337692@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 791923275174852@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269507637863846292547130774971231941912697656176794927104471554101673779007646046026206435532294604602620643553229(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 272206880880764@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1923801470906317@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1923801470906317@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 1923801470906317@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2312286893655375@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269511497607501298147139921008712270712697656176794927104471614953453886321246046412180801032854604641218080103285(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 880724681953900@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1962398907456373@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1962398907456373@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 1962398907456373@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 3226890641688255@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269515333007037279947140018489855310022697656176794927104471612453454926022446046795720754631034604679572075463103(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 855724692350912@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2000752902816191@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2000752902816191@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2000752902816191@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 3236638755992186@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269519143918053613047145037082413634152697656176794927104471643877927695999846047176811856264344604717681185626434(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1169969420050686@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2038862012979522@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2038862012979522@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2038862012979522@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 3738498011824599@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269522930197071651647154331513764667632697656176794927104471715472437335667546047555439758068204604755543975806820(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1885914516447363@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2076724803159908@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2076724803159908@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2076724803159908@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 164341519557451@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269526691701540130747154361342033065962697656176794927104471712246736267464446047931590204916114604793159020491611(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1853657505765332@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2114339847844699@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2114339847844699@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2114339847844699@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 167324346397284@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269530428289840533047145084383569049362697656176794927104471634578217990808846048305249034956344604830524903495634(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1076972322998776@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2151705730848722@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2151705730848722@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2151705730848722@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 3743228127366120@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269534139821292421147147698158494067212697656176794927104471649072448735332646048676402180145154604867640218014515(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1221914630444014@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2188821045367603@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2188821045367603@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2188821045367603@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 4004605619867905@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269537826156158733447158946314776148682697656176794927104471763098065860487246049045035666776384604904503566677638(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2362170801695560@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2225684394030726@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2225684394030726@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2225684394030726@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 625821620705556@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269541487155651045847162220721194853852697656176794927104471802974056799261846049411135616007624604941113561600762(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2760930711083306@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2262294388953850@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2262294388953850@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2262294388953850@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 953262262576073@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269545122681934796747158942983733842222697656176794927104471755689295252741246049774688244382714604977468824438271(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2288083095618100@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2298649651791359@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2298649651791359@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2298649651791359@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 625488516474910@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269548732598134476247158945340705575852697656176794927104471752135058648170646050135679864350664605013567986435066(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2252540729572394@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2334748813788154@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2334748813788154@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2334748813788154@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 625724213648273@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269552316768338779747162219243655489452697656176794927104471791510141312969846050494096884781014605049409688478101(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2646291556220386@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2370590515831189@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2370590515831189@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2370590515831189@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 953114508639633@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269555875057605724947158915481958050192697656176794927104471744762183258246146050849925811475534605084992581147553(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2178811975673149@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2406173408500641@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2406173408500641@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2406173408500641@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 622738338895707@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269559407331967732047147525400946520372697656176794927104471627121736212586846051203153247676244605120315324767624(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1002407505216556@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2441496152120712@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2441496152120712@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2441496152120712@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 3987329865113221@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269562913458436667747148828108512164182697656176794927104471632761147400214446051553765894569814605155376589456981(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1058801617092832@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2476557416810069@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2476557416810069@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2476557416810069@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 4117600621677602@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269566393305008852147161311584861291102697656176794927104471765508502197512846051901750551788254605190175055178825(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2386275165065816@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2511355882531913@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2511355882531913@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2511355882531913@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 862348629219798@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269569846740670028647166536800357194442697656176794927104471828896327466823346052247094117905904605224709411790590(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3020153417758921@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2545890239143678@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2545890239143678@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2545890239143678@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1384870178810132@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269573273635400296547164717407416906372697656176794927104471802122482957789846052589783590932694605258978359093269(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2752414972668586@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2580159186446357@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2580159186446357@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2580159186446357@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1202930884781325@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269576673860179006047166482971122152882697656176794927104471820998609748274446052929806068803644605292980606880364(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2941176240573432@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2614161434233452@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2614161434233452@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2614161434233452@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1379487255305976@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269580047286989616147172184379154390462697656176794927104471889295204063094946053267148749864654605326714874986465(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3624142183721637@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2647895702339553@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2647895702339553@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2647895702339553@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1949628058529734@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269583393788824514047170196836210246142697656176794927104471860593381624683046053601798933354444605360179893335444(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3337123959337518@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2681360720688532@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2681360720688532@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2681360720688532@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1750873764115302@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269586713239689797047161138302361154372697656176794927104471743950401977702246053933744019882744605393374401988274(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2170694162867710@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2714555229341362@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2714555229341362@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2714555229341362@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 845020379206125@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269590005514610016247161112084016840692697656176794927104471740594328592202246054262971511904664605426297151190466(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2137133429012710@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2747477978543554@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2747477978543554@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2747477978543554@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 842398544774757@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269593270489632881847170103644720957272697656176794927104471848808972362940346054589469014191224605458946901419122(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3219279866720091@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2780127728772210@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2780127728772210@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2780127728772210@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1741554615186415@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269596508041833929447172019861059127592697656176794927104471868982854644874746054913224234295984605491322423429598(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3421018689539435@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2812503250782686@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2812503250782686@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2812503250782686@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1933176249003447@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269599718049321148647166264756723279582697656176794927104471794976760576010346055234224983017904605523422498301790(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2680957748850791@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2844603325654878@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2844603325654878@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2844603325654878@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1357665815418646@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269602900391239571847164431455646580612697656176794927104471769503572603516846055552459174860224605555245917486022(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2426225869125856@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2876426744839110@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2876426744839110@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2876426744839110@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1174335707748749@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269606054947775824347166154199395425902697656176794927104471787490369050330846055867914828485474605586791482848547(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2606093833593996@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2907972310201635@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2907972310201635@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2907972310201635@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1346610082633278@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269609181600162635747160870881422979802697656176794927104471720565832175108046056180580067166614605618058006716661(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1936848464841768@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2939238834069749@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2939238834069749@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2939238834069749@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 818278285388668@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269612280230683310647147948430249155032697656176794927104471590719088325317146056490443119234104605649044311923410(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 638381026343859@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2970225139276498@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2970225139276498@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 2970225139276498@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 4029632795376687@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269615350722676161447148546073947144242697656176794927104471592201802019011546056797492318519184605679749231851918(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 653208163280803@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3000930059205006@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3000930059205006@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3000930059205006@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 4089397165175608@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269618392960538900047161996962798216772697656176794927104471726153539238377446057101716104793044605710171610479304(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1992725535474462@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3031352437832392@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3031352437832392@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3031352437832392@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 930886422912365@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269621406829732990347168232000716934892697656176794927104471797801485319218146057403103024202074605740310302420207(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2709204996282869@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3061491129773295@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3061491129773295@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3061491129773295@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1554390214784177@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269624392216787960647167274964005226832697656176794927104471783616363188740046057701641729699104605770164172969910(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2567353774978088@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3091345000322998@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3091345000322998@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3091345000322998@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1458686543613371@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269627349009305675747170066022382149962697656176794927104471813846341251488446057997320981470614605799732098147061(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2869653555605572@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3120912925500149@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3120912925500149@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3120912925500149@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1737792381305684@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269630277095964568347177159219552868612697656176794927104471894500318252105946058290129647359874605829012964735987(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3676193325611747@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3150193792089075@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3150193792089075@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3150193792089075@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2447112098377549@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269633176366523830947176039912469283392697656176794927104471878290879364524046058580056703286134605858005670328613(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3514098936735928@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3179186497681701@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3179186497681701@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3179186497681701@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2335181390019027@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269636046711827565547167018882234243512697656176794927104471769938825839773446058867091233659594605886709123365959(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2430578401488422@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3207889950719047@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3207889950719047@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3207889950719047@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1433078366515039@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269638888023808893747167885978549736852697656176794927104471777484002056105846059151222431792414605915122243179241(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2506030163651746@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3236303070532329@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3236303070532329@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3236303070532329@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1519787998064373@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269641700195494025447179082015702517982697656176794927104471904766955838576846059432439600305584605943243960030558(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3778859701476456@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3264424787383646@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3264424787383646@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3264424787383646@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2639391713342486@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269644483121006286147182393859310586072697656176794927104471940074812690376646059710732151531654605971073215153165(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 4131938269994454@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3292254042506253@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3292254042506253@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3292254042506253@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2970576074149295@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269647236695570103147176754936781561712697656176794927104471872113529253002046059986089607913354605998608960791335(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3452325435620708@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3319789788144423@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3319789788144423@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3319789788144423@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2406683821246859@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269649960815514950547175631151859784932697656176794927104471856459443960957246060258501602398094606025850160239809(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3295784582700260@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3347030987592897@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3347030987592897@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3347030987592897@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2294305329069181@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269652655378279251947178794176182935492697656176794927104471889957561257229446060527957878828234606052795787882823(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3630765755662982@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3373976615235911@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3373976615235911@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3373976615235911@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2610607761384237@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269655320282414242347173402922822560462697656176794927104471825779451674330646060794448292327274606079444829232727(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2988984659833994@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3400625656585815@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3400625656585815@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3400625656585815@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2071482425346734@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269657955427587787347161223539004479352697656176794927104471684961771821360846061057962809681774606105796280968177(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1580807861304296@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3426977108321265@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3426977108321265@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3426977108321265@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 853544043538623@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269660560714588160447161166744092835842697656176794927104471682326578324544846061318491509719084606131849150971908(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1554455926336136@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3453029978324996@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3453029978324996@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3453029978324996@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 847864552374272@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269663136045327778647173193870500453032697656176794927104471816084349041452446061576024583680904606157602458368090(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2892033633505212@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3478783285721178@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3478783285721178@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3478783285721178@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2050577193135991@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269665681322846895147178417037218081072697656176794927104471872483744854028446061830552335592554606183055233559255(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3456027591630972@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3504236060912343@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3504236060912343@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3504236060912343@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2572893864898795@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269668196451317249947175126066494467612697656176794927104471833090705056114446062082065182628034606208206518262803(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3062097193651832@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3529387345615891@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3529387345615891@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3529387345615891@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2243796792537449@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269670681336045677747176093589395698462697656176794927104471841572738269884246062330553655470814606233055365547081(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3146917525789530@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3554236192900169@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3554236192900169@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3554236192900169@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2340549082660534@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269673135883477672947181517347292707222697656176794927104471899693000915869546062576008398670334606257600839867033(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3728120152249383@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3578781667220121@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3578781667220121@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3578781667220121@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2882924872361410@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269675560001200912047178088796855966192697656176794927104471859137143240269846062818420170994244606281842017099424(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3322561575493386@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3603022844452512@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3603022844452512@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3603022844452512@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2540069828687307@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269677953597948732847166915736974613572697656176794927104471733055712546296746063057779845776324606305777984577632(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2061747268553655@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3626958811930720@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3626958811930720@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3626958811930720@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1422763840552045@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269680316583603570747165930025143953392697656176794927104471720264880961955246063294078411260114606329407841126011(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1933838952710240@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3650588668479099@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3650588668479099@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3650588668479099@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1324192657486027@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269682648869200351347174630483628837522697656176794927104471814260923554721646063527306970938174606352730697093817(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2873799378637904@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3673911524446905@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3673911524446905@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3673911524446905@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2194238505974440@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269684950366929840147175566311282162732697656176794927104471822469274250068346063757456743887054606375745674388705(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2955882885591371@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3696926501741793@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3696926501741793@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3696926501741793@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2287821271306961@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269687220990141948447168488851149175112697656176794927104471742887598608454246063984519065097884606398451906509788(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2160066129175230@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3719632733862876@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3719632733862876@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3719632733862876@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1580075258008199@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269689460653348995647165625120871591422697656176794927104471709795367626330646064208485385802604606420848538580260(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1829143819353994@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3742029365933348@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3742029365933348@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3742029365933348@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1293702230249830@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269691669272228927947166406877886547982697656176794927104471716620444935355046064429347273795834606442934727379583(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1897394592444238@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3764115554732671@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3764115554732671@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3764115554732671@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1371877931745486@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269693846763628492747160222967130505092697656176794927104471647745849902887846064647096413752314606464709641375231(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1208648642119566@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3785890468728319@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3785890468728319@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3785890468728319@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 753486856141197@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269695993045566369547145519289141957032697656176794927104471524644659884387646064861724607539994606486172460753999(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 4481236369305060@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3807353288107087@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3807353288107087@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3807353288107087@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 3786718684656887@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269698108037236256647145730263194499152697656176794927104471524644659884387646065073223774528704606507322377452870(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 4481236369305060@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3828503204805958@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3828503204805958@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3828503204805958@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 3807816089911099@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269700191659009912947160625352118752532697656176794927104471647745849902887846065281585951894334606528158595189433(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1208648642119566@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3849339422542521@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3849339422542521@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3849339422542521@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 793725354965941@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269702243832440156247167158362303344102697656176794927104471716620444935355046065486803294918664606548680329491866(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1897394592444238@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3869861156844954@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3869861156844954@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3869861156844954@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1447026373425098@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269704264480263817047166665942055067892697656176794927104471709795367626330646065688868077284744606568886807728474(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1829143819353994@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3890067635081562@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3890067635081562@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3890067635081562@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1397784348597477@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269706253526404646547169896907711121382697656176794927104471742887598608454246065887772691367694606588777269136769(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2160066129175230@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3909958096489857@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3909958096489857@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3909958096489857@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1720880914202826@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269708210895976182047177492676012820822697656176794927104471822469274250068346066083509648521244606608350964852124(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2955882885591371@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3929531792205212@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3929531792205212@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3929531792205212@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2480457744372770@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269710136515284565247176881875289707592697656176794927104471814260923554721646066276071579359564606627607157935956(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2873799378637904@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3948787985289044@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3948787985289044@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3948787985289044@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2419377672061447@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269712030311831317747168196602931760582697656176794927104471720264880961955246066465451234034814606646545123403481(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1933838952710240@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3967725950756569@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3967725950756569@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3967725950756569@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1550850436266746@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269713892214316069847169535302465927772697656176794927104471733055712546296746066651641482510024606665164148251002(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2061747268553655@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3986344975604090@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3986344975604090@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 3986344975604090@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1684720389683465@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269715722152639245347181578399589521642697656176794927104471859137143240269846066834635314827574606683463531482757(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3322561575493386@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4004644358835845@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4004644358835845@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4004644358835845@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2889030102042852@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269717520057904700647185573636891727192697656176794927104471899693000915869546067014425841373104606701442584137310(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3728120152249383@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4022623411490398@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4022623411490398@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4022623411490398@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 3288553832263407@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269719285862422318747180221951078937402697656176794927104471841572738269884246067191006293134914606719100629313491(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3146917525789530@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4040281456666579@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4040281456666579@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4040281456666579@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2753385250984428@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269721019499710557547179562996976444032697656176794927104471833090705056114446067364370021958794606736437002195879(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3062097193651832@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4057617829548967@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4057617829548967@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4057617829548967@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2687489840735091@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269722720904498953047183457603034799342697656176794927104471872483744854028446067534510500798344606753451050079834(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3456027591630972@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4074631877432922@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4074631877432922@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4074631877432922@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 3076950446570622@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269724390012730576547178223312681897862697656176794927104471816084349041452446067701421323960694606770142132396069(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2892033633505212@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4091322959749157@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4091322959749157@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4091322959749157@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2553521411280474@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269726026761564446447165569854740745152697656176794927104471682326578324544846067865096207347684606786509620734768(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1554455926336136@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4107690448087856@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4107690448087856@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4107690448087856@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1288175617165203@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269727631089377894447165930164298140522697656176794927104471684961771821360846068025528988692484606802552898869248(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1580807861304296@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4123733726222336@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4123733726222336@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4123733726222336@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1324206572904740@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269729202935768884947179548806709059312697656176794927104471825779451674330646068182713627791534606818271362779153(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2988984659833994@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4139452190132241@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4139452190132241@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4139452190132241@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2686070813996619@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269730742241558289847185846169367080272697656176794927104471889957561257229446068336644206732024606833664420673202(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3630765755662982@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4154845248026290@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4154845248026290@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4154845248026290@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 3315807079798715@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269732248948792116147182756527342294772697656176794927104471856459443960957246068487314930114654606848731493011465(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3295784582700260@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4169912320364553@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4169912320364553@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4169912320364553@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 3006842877320165@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269733723000743688147184394143414787422697656176794927104471872113529253002046068634720125271854606863472012527185(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3452325435620708@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4184652839880273@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4184652839880273@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4184652839880273@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 3170604484569430@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269735164341915782847191087806203468472697656176794927104471940074812690376646068778854242481324606877885424248132(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 4131938269994454@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4199066251601220@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4199066251601220@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4199066251601220@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 3839970763437535@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269736572918042720047187805920256011062697656176794927104471904766955838576846068919711855175044606891971185517504(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3778859701476456@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4213152012870592@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4213152012870592@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4213152012870592@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 3511782168691794@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269737948676092404447175595128527729202697656176794927104471777484002056105846069057287660143484606905728766014348(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2506030163651746@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4226909593367436@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4226909593367436@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4226909593367436@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2290702995863608@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269739291564268323147174967170788098412697656176794927104471769938825839773446069191576477735354606919157647773535(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2430578401488422@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4240338475126623@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4240338475126623@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4240338475126623@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2227907221900529@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269740601532011495247185602292191548222697656176794927104471878290879364524046069322573252052564606932257325205256(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3514098936735928@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4253438152558344@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4253438152558344@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4253438152558344@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 3291419362245510@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269741878530002375847187294186015442122697656176794927104471894500318252105946069450273051140624606945027305114062(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3676193325611747@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4266208132467150@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4266208132467150@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4266208132467150@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 3460608744634900@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269743122510162712047179543189585363692697656176794927104471813846341251488446069574671067174244606957467106717424(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2869653555605572@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4278647934070512@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4278647934070512@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4278647934070512@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2685509101627057@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269744333425657354147176690751032370022697656176794927104471783616363188740046069695762616638454606969576261663845(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2567353774978088@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4290757089016933@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4290757089016933@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4290757089016933@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2400265246327690@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269745511230896018047178170059964966472697656176794927104471797801485319218146069813543140504844606981354314050484(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2709204996282869@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4302535141403572@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4302535141403572@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4302535141403572@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2548196139587335@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269746655881535002347171247758939851972697656176794927104471726153539238377446069928008204403274606992800820440327(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1992725535474462@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4313981647793415@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4313981647793415@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4313981647793415@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1855966037075885@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269747767334478857347158198211045564352697656176794927104471592201802019011546070039153498788774607003915349878877(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 653208163280803@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4325096177231965@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4325096177231965@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4325096177231965@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 551011247647123@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269748845547882007847158114430555159422697656176794927104471590719088325317146070146974839103824607014697483910382(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 638381026343859@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4335878311263470@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4335878311263470@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4335878311263470@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 542633198606630@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269749890481150328747170932036044795362697656176794927104471720565832175108046070251468165935914607025146816593591(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1936848464841768@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4346327643946679@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4346327643946679@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4346327643946679@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1824393747570224@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269750902094942673047177587484992049672697656176794927104471787490369050330846070352629545170344607035262954517034(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2606093833593996@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4356443781870122@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4356443781870122@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4356443781870122@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2489938642295655@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269751880351172353247175893455049622362697656176794927104471769503572603516846070450455168138364607045045516813836(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2426225869125856@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4366226344166924@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4366226344166924@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4366226344166924@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2320535648052924@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269752825213008575247178477289954892352697656176794927104471794976760576010346070544941351760564607054494135176056(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2680957748850791@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4375674962529144@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4375674962529144@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4375674962529144@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2578919138579923@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269753736644877824847185852980904544432697656176794927104471868982854644874746070636084538685524607063608453868552(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3421018689539435@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4384789281221640@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4384789281221640@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4384789281221640@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 3316488233545131@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269754614612465207347183937481216335542697656176794927104471848808972362940346070723881297423774607072388129742377(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3219279866720091@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4393568957095465@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4393568957095465@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4393568957095465@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 3124938264724242@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269755459082715739347173310470529028722697656176794927104471740594328592202246070808328322476974607080832832247697(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2137133429012710@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4402013659600785@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4402013659600785@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4402013659600785@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2062237195993560@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269756270023835593247173702383153764632697656176794927104471743950401977702246070889422434462364607088942243446236(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2170694162867710@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4410123070799324@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4410123070799324@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4410123070799324@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2101428458467151@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269757047405293294147185313299919508942697656176794927104471860593381624683046070967160580232454607096716058023245(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3337123959337518@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4417896885376333@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4417896885376333@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4417896885376333@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 3262520135041582@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269757791197820869547188223289528997822697656176794927104471889295204063094946071041539832989994607104153983298999(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3624142183721637@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4425334810652087@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4425334810652087@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4425334810652087@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 3553519095990470@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269758501373414951247181511672546235522697656176794927104471820998609748274446071112557392398164607111255739239816(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2941176240573432@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4432436566592904@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4432436566592904@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4432436566592904@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2882357397714240@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269759177905337829447179693473325144512697656176794927104471802122482957789846071180210584685984607118021058468598(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2752414972668586@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4439201885821686@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4439201885821686@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4439201885821686@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2700537475605139@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269759820768118459647182405414196932722697656176794927104471828896327466823346071244496862749004607124449686274900(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 3020153417758921@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4445630513627988@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4445630513627988@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4445630513627988@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2971731562783960@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269760429937553421547176154024398468852697656176794927104471765508502197512846071305413806245194607130541380624519(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2386275165065816@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4451722207977607@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4451722207977607@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4451722207977607@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2346592582937573@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269761005390707830247162991282572426862697656176794927104471632761147400214446071362959121686064607136295912168606(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1058801617092832@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4457476739521694@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4457476739521694@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4457476739521694@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1030318400333374@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269761547105916199647162463343696305132697656176794927104471627121736212586846071417130642523004607141713064252300(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1002407505216556@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4462893891605388@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4462893891605388@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4462893891605388@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 977524512721201@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269762055062783258347174211908959914792697656176794927104471744762183258246146071467926329228874607146792632922887(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2178811975673149@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4467973460275975@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4467973460275975@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4467973460275975@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2152381039082167@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269762529242184717447178905854786477682697656176794927104471791510141312969846071515344269374784607151534426937478(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2646291556220386@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4472715254290566@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4472715254290566@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4472715254290566@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2621775621738456@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269762969626267990447175014880090557132697656176794927104471752135058648170646071559382677702084607155938267770208(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2252540729572394@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4477119095123296@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4477119095123296@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4477119095123296@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2232678152146401@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269763376198452865547175399915521901122697656176794927104471755689295252741246071600039896189594607160003989618959(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2288083095618100@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4481184816972047@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4481184816972047@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4481184816972047@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2271181695280800@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269763748943432129747180146687466387102697656176794927104471802974056799261846071637314394116014607163731439411601(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2760930711083306@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4484912266764689@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4484912266764689@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4484912266764689@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2745858889729398@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269764087847172145347176193194560368962697656176794927104471763098065860487246071671204768117574607167120476811757(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 2362170801695560@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4488301304164845@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4488301304164845@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4488301304164845@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 2350509599127584@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269764392896913377947164829390371569182697656176794927104471649072448735332646071701709742240834607170170974224083(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1221914630444014@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4491351801577171@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4491351801577171@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4491351801577171@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1214129180247606@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269764664081170877247163398739903629972697656176794927104471634578217990808846071728828167990764607172882816799076(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1076972322998776@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4494063644152164@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4494063644152164@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4494063644152164@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1071064133453685@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269764901389734709247171174118087286732697656176794927104471712246736267464446071752559024373964607175255902437396(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1853657505765332@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4496436729790484@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4496436729790484@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4496436729790484@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1848601951819361@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269765104813670340647171510862131103722697656176794927104471715472437335667546071772901417937104607177290141793710(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1885914516447363@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4498470969146798@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4498470969146798@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4498470969146798@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1882276356201060@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269765274345318975347164366166400670702697656176794927104471643877927695999846071789854582800574607178985458280057(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 1169969420050686@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4500166285633145@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4500166285633145@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4500166285633145@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 1167806783157758@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269765409978297842347161232987177509942697656176794927104471612453454926022446071803417880687274607180341788068727(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 855724692350912@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4501522615421815@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4501522615421815@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4501522615421815@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 854488860841682@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269765511707500436947161489010594008752697656176794927104471614953453886321246071813590800946734607181359080094673(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 880724681953900@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4502539907447761@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4502539907447761@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4502539907447761@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 880091202491563@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269765579529096711947155408144563656852697656176794927104471554101673779007646071820372960574234607182037296057423(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1047@11 > e0, and[1047@11 = e0, 272206880880764@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4503218123410511@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4503218123410511@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4503218123410511@52 <= mr ] ], 
        or[ 1047@11 > er, and[1047@11 = er, 272004599456373@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main269765613440533222647137277051477523382697656176794927104471372774028478035346071823764104225304607182376410422530(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 599@11 < e0, and[599@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2962530055241537@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4503557237775618@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4503557237775618@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 598@11 < er, and[598@11 = er, 4503557237775618@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2962494918213522@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main290288875376102616146760787812609238702936346957045563392470920137490578001445737242155154801774573724215515480177(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 2939764303611694@52 >= m0 ] ] ,
        or[ 1015@11 < e1, and[1015@11 = e1, 2570593734426737@52 <= m1 ] ], 
        or[ 1015@11 > e1, and[1015@11 = e1, 2570593734426737@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 644@11 < er, and[644@11 = er, 2570593734426737@52 <= mr ] ], 
        or[ 1038@11 > er, and[1038@11 = er, 1342368050349022@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main291012713833844300546848152211824601352936346957045563392471099426169385253245809626000928970214580962600092897021(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 229051464313716@52 >= m0 ] ] ,
        or[ 1017@11 < e1, and[1017@11 = e1, 801779057102589@52 <= m1 ] ], 
        or[ 1017@11 > e1, and[1017@11 = e1, 801779057102589@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 646@11 < er, and[646@11 = er, 801779057102589@52 <= mr ] ], 
        or[ 1040@11 > er, and[1040@11 = er, 1071608717144295@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main291366316971195161746889502008231336122936346957045563392471156583000481243745844986314664056334584498631466405633(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 800619775273621@52 >= m0 ] ] ,
        or[ 1017@11 < e1, and[1017@11 = e1, 4337810430611201@52 <= m1 ] ], 
        or[ 1017@11 > e1, and[1017@11 = e1, 4337810430611201@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 646@11 < er, and[646@11 = er, 4337810430611201@52 <= mr ] ], 
        or[ 1041@11 > er, and[1041@11 = er, 702988730447276@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main291551341425516883546909559374261692742936346957045563392471151066287199307945863488760096228514586348876009622851(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 745452642454263@52 >= m0 ] ] ,
        or[ 1018@11 < e1, and[1018@11 = e1, 1684455346457923@52 <= m1 ] ], 
        or[ 1018@11 > e1, and[1018@11 = e1, 1684455346457923@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 647@11 < er, and[647@11 = er, 1684455346457923@52 <= mr ] ], 
        or[ 1041@11 > er, and[1041@11 = er, 2708725333482938@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main291727983230168880346931267326251006732936346957045563392471178690606682385845881152940561428194588115294056142819(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1021695837285042@52 >= m0 ] ] ,
        or[ 1018@11 < e1, and[1018@11 = e1, 3450873392977891@52 <= m1 ] ], 
        or[ 1018@11 > e1, and[1018@11 = e1, 3450873392977891@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 647@11 < er, and[647@11 = er, 3450873392977891@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 375920905043841@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main291868880548495608346949245821005475442936346957045563392471244950164099472245895242672394100994589524267239410099(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1684291411455906@52 >= m0 ] ] ,
        or[ 1019@11 < e1, and[1019@11 = e1, 356246948874675@52 <= m1 ] ], 
        or[ 1019@11 > e1, and[1019@11 = e1, 356246948874675@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 648@11 < er, and[648@11 = er, 356246948874675@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 2173770380490712@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main291957068367600859846960535952092884852936346957045563392471238465298401121645904061454304626144590406145430462614(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1619442754472400@52 >= m0 ] ] ,
        or[ 1019@11 < e1, and[1019@11 = e1, 1238125139927190@52 <= m1 ] ], 
        or[ 1019@11 > e1, and[1019@11 = e1, 1238125139927190@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 648@11 < er, and[648@11 = er, 1238125139927190@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 3302783489231653@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292045169718443088146961090366819613692936346957045563392471160781466711185645912871589388848974591287158938884897(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 842604437573040@52 >= m0 ] ] ,
        or[ 1019@11 < e1, and[1019@11 = e1, 2119138648349473@52 <= m1 ] ], 
        or[ 1019@11 > e1, and[1019@11 = e1, 2119138648349473@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 648@11 < er, and[648@11 = er, 2119138648349473@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 3358224961904537@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292133171333282918746972957495804986932936346957045563392471171789486729365645921671750872832034592167175087283203(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 952684637754840@52 >= m0 ] ] ,
        or[ 1019@11 < e1, and[1019@11 = e1, 2999154796747779@52 <= m1 ] ], 
        or[ 1019@11 > e1, and[1019@11 = e1, 2999154796747779@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 648@11 < er, and[648@11 = er, 2999154796747779@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 41338233071365@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292221059959400852146988080229231965772936346957045563392471277089801774928045930460613484625374593046061348462537(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2005687788210464@52 >= m0 ] ] ,
        or[ 1019@11 < e1, and[1019@11 = e1, 3878041057927113@52 <= m1 ] ], 
        or[ 1019@11 > e1, and[1019@11 = e1, 3878041057927113@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 648@11 < er, and[648@11 = er, 3878041057927113@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 1553611575769249@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292296219088719132546997952412022160022936346957045563392471311426921193544245937976526416453414593797652641645341(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2349058982396626@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 126032723739421@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 126032723739421@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 649@11 < er, and[649@11 = er, 126032723739421@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 2540829854788674@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292340030569004948746999244073177586152936346957045563392471263663316725817245942357674445035034594235767444503503(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1871422937719356@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 564147526597583@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 564147526597583@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 649@11 < er, and[649@11 = er, 564147526597583@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 2669995970331287@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292383765730882690047004652840627045562936346957045563392471257264991352683045946731190632809164594673119063280916(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1807439683988014@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 1001499145374996@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 1001499145374996@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 649@11 < er, and[649@11 = er, 1001499145374996@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 3210872715277228@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292427417987997848247015206089424282832936346957045563392471290889645510386145951096416344324984595109641634432498(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2143686225565045@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 1438021716526578@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 1438021716526578@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 649@11 < er, and[649@11 = er, 1438021716526578@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 4266197595000955@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292470980766481067447015074818884154712936346957045563392471244555225336808345955452694192646904595545269419264690(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1680342023829267@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 1873649501358770@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 1873649501358770@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 649@11 < er, and[649@11 = er, 1873649501358770@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 4253070540988143@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292514447505938144647004228361409505712936346957045563392471133385806805120845959799368138354624595979936813835462(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 568647838512392@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 2308316895929542@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 2308316895929542@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 649@11 < er, and[649@11 = er, 2308316895929542@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 3168424793523243@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292557811660438000647009583619776643742936346957045563392471136315280683465045964135783588340224596413578358834022(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 597942577295834@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 2741958440928102@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 2741958440928102@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 649@11 < er, and[649@11 = er, 2741958440928102@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 3703950630237046@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292601066699498473847026177377171121712936346957045563392471255333590645738945968461287494387544596846128749438754(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1788125676918573@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 3174508831532834@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 3174508831532834@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 649@11 < er, and[649@11 = er, 3174508831532834@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 859726742314347@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292644206109069786247034141197328417552936346957045563392471310317953995019145972775228451518784597277522845151878(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2337969310411375@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 3605902927245958@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 3605902927245958@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 649@11 < er, and[649@11 = er, 3605902927245958@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 1656108758043931@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292687223392515535547034842518108141672936346957045563392471283251778802778445977076956796093714597707695679609371(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2067307558488968@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 4036075761703451@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 4036075761703451@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 649@11 < er, and[649@11 = er, 4036075761703451@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 1726240836016343@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292730112071591064947039403270896566772936346957045563392471297632964889692945981365824703646654598136582470364665(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2211119419358113@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 4464962552458745@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 4464962552458745@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 649@11 < er, and[649@11 = er, 4464962552458745@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 2182316114858853@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292753420733250651247048716178849917562936346957045563392471356354536056559245983696690869605284598369669086960528(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2798335131026776@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 194449541684112@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 194449541684112@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 650@11 < er, and[650@11 = er, 194449541684112@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 3113606910193932@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292774726790272242347049064730717414482936346957045563392471327872570645347945985827296571764394598582729657176439(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2513515476914663@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 407510111900023@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 407510111900023@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 650@11 < er, and[650@11 = er, 407510111900023@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 3148462096943624@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292795958887787608147040243641469474032936346957045563392471221253657436840245987950506323300974598795050632330097(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1447326344829586@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 619831087053681@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 619831087053681@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 650@11 < er, and[650@11 = er, 619831087053681@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 2266353172149579@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292817113828320960747042429634991229142936346957045563392471216109666579491645990066000376636234599006600037663623(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1395886436256100@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 831380492387207@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 831380492387207@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 650@11 < er, and[650@11 = er, 831380492387207@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 2484952524325090@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292838188426016069547056729544849760972936346957045563392471309818115688209645992173460146147114599217346014614711(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2332970927343280@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 1042126469338295@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 1042126469338295@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 650@11 < er, and[650@11 = er, 1042126469338295@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 3914943510178273@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292859179507116040447061889813968956082936346957045563392471325262254241262645994272568256144204599427256825614420(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2487412312873810@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 1252037280338004@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 1252037280338004@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 650@11 < er, and[650@11 = er, 1252037280338004@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 4430970422097784@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292880083910441270847056207101938617902936346957045563392471257853865585950845996363008588667244599636300858866724(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1813328426320692@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 1461081313590308@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 1461081313590308@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 650@11 < er, and[650@11 = er, 1461081313590308@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 3862699219063966@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292900898487865512347055785276496587192936346957045563392471233475809302312945998444466331091394599844446633109139(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1569547863484313@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 1669227087832723@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 1669227087832723@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 650@11 < er, and[650@11 = er, 1669227087832723@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 3820516674860895@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292921620104789967147060534062115637062936346957045563392471247272088920982846000516628023536874600051662802353687(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1707510659671012@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 1876443257077271@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 1876443257077271@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 650@11 < er, and[650@11 = er, 1876443257077271@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 4295395236765882@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292942245640615346247054576236253967252936346957045563392471187082876948144046002579181606074784600257918160607478(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1105618539942624@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 2082698615331062@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 2082698615331062@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 650@11 < er, and[650@11 = er, 2082698615331062@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 3699612650598901@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292962771989211821247039878255609137632936346957045563392471068809302493732846004631816465722284600463181646572228(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 4426482422769008@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 2287962101295812@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 2287962101295812@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 650@11 < er, and[650@11 = er, 2287962101295812@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 2229814586115939@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main292983196059386795247041903176089988802936346957045563392471068809302493732846006674223483219684600667422348321968(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 4426482422769008@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 2492202803045552@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 2492202803045552@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 650@11 < er, and[650@11 = er, 2492202803045552@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 2432306634201056@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293003514775350425547062207286349160132936346957045563392471187082876948144046008706095079582714600870609507958271(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1105618539942624@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 2695389962681855@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 2695389962681855@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 650@11 < er, and[650@11 = er, 2695389962681855@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 4462717660118189@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293023725077178826147068615954670348272936346957045563392471247272088920982846010727125262422774601072712526242277(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1707510659671012@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 2897492980965861@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 2897492980965861@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 650@11 < er, and[650@11 = er, 2897492980965861@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 599984864866507@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293043823921274880947068837507462935312936346957045563392471233475809302312946012737009672028254601273700967202825(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1569547863484313@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 3098481421926409@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 3098481421926409@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 650@11 < er, and[650@11 = er, 3098481421926409@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 622140144125211@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293063808280826598547072296559631852742936346957045563392471257853865585950846014735445627200014601473544562720001(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1813328426320692@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 3298325017443585@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 3298325017443585@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 650@11 < er, and[650@11 = er, 3298325017443585@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 968045361016954@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293083675146262938747079677374060353822936346957045563392471325262254241262646016722132170834034601672213217083403(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2487412312873810@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 3496993671806987@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 3496993671806987@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 650@11 < er, and[650@11 = er, 3496993671806987@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 1706126803867062@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293103421525707042747079804330781607912936346957045563392471309818115688209646018696770115244434601869677011524443(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2332970927343280@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 3694457466248027@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 3694457466248027@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 650@11 < er, and[650@11 = er, 3694457466248027@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 1718822475992471@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293123044445426799247072560546603191722936346957045563392471216109666579491646020659062087220084602065906208722008(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1395886436256100@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 3890686663445592@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 3890686663445592@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 650@11 < er, and[650@11 = er, 3890686663445592@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 994444058150852@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293142540950282677247074328048182154762936346957045563392471221253657436840246022608712572807884602260871257280788(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1447326344829586@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 4085651712004372@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 4085651712004372@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 650@11 < er, and[650@11 = er, 4085651712004372@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 1171194216047156@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293161908104172759147086004021605463002936346957045563392471327872570645347946024545427961816074602454542796181607(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2513515476914663@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 4279323250905191@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 4279323250905191@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 650@11 < er, and[650@11 = er, 4279323250905191@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 2338791558377980@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293181142990474907247090340628129252972936346957045563392471356354536056559246026468916592030884602646891659203088(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2798335131026776@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 4471672113926672@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 4471672113926672@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 650@11 < er, and[650@11 = er, 4471672113926672@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 2772452210756977@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293192289227152642647085913138741654912936346957045563392471297632964889692946027583540259804424602758354025980442(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2211119419358113@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 79534853333530@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 79534853333530@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 79534853333530@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 2329703271997171@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293201770067838716947085832909903942842936346957045563392471283251778802778446028531624328411854602853162432841185(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2067307558488968@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 174343260194273@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 174343260194273@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 174343260194273@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 2321680388225964@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293211180460425587047090073870183538212936346957045563392471310317953995019146029472663587098864602947266358709886(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2337969310411375@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 268447186062974@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 268447186062974@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 268447186062974@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 2745776416185501@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293220518987742743547085552320220573432936346957045563392471255333590645738946030406516318814514603040651631881451(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1788125676918573@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 361832459234539@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 361832459234539@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 361832459234539@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 2293621419889023@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293229784243442322447073743801364601562936346957045563392471136315280683465046031333041888772404603133304188877240(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 597942577295834@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 454485016230328@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 454485016230328@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 454485016230328@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 1112769534291836@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293238974832210895547074456394929675112936346957045563392471133385806805120846032252100765629714603225210076562971(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 568647838512392@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 546390903916059@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 546390903916059@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 546390903916059@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 1184028890799191@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293248089369979599947088173606311843932936346957045563392471244555225336808346033163554542500154603316355454250015(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1680342023829267@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 637536281603103@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 637536281603103@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 637536281603103@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 2555750029016073@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293257126484132573647094796837884727672936346957045563392471290889645510386146034067265957797524603406726595779752(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2143686225565045@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 727907423132840@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 727907423132840@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 727907423132840@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 3218073186304447@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293266084813713666347092146263787934012936346957045563392471257264991352683046034963098915906794603496309891590679(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1807439683988014@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 817490718943767@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 817490718943767@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 817490718943767@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 2953015776625081@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293274963009631394347094158981928718012936346957045563392471263663316725817246035850918507679594603585091850767959(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1871422937719356@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 906272678121047@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 906272678121047@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 906272678121047@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 3154287590703481@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293283759734862109047101235009601641632936346957045563392471311426921193544246036730591030751064603673059103075106(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2349058982396626@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 994239930428194@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 994239930428194@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 994239930428194@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 3861890357995843@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293292473664651347647098302721857398182936346957045563392471277089801774928046037601984009674924603760198400967492(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2005687788210464@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1081379228320580@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1081379228320580@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 1081379228320580@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 3568661583571498@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293301103486713336147086289814062233102936346957045563392471171789486729365646038464966215873774603846496621587377(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 952684637754840@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1167677448940465@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1167677448940465@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 1167677448940465@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 2367370804054990@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293309647901428615147085917903850688212936346957045563392471160781466711185646039319407687401674603931940768740167(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 842604437573040@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1253121596093255@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1253121596093255@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 1253121596093255@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 2330179782900501@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293318105622039757247096997733001855332936346957045563392471238465298401121646040165179748515884604016517974851588(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1619442754472400@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1337698802204676@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1337698802204676@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 1337698802204676@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 3438162698017213@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293326475374845148347098988832602638652936346957045563392471244950164099472246041002155029054994604100215502905499(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1684291411455906@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1421396330258587@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1421396330258587@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 1421396330258587@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 3637272658095545@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293334755899390802347091287542660575932936346957045563392471178690606682385846041830207483620394604183020748362039(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1021695837285042@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1504201575715127@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1504201575715127@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 1504201575715127@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 2867143663889273@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293342945948660180847088557028554257642936346957045563392471151066287199307946042649212410558244604264921241055824(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 745452642454263@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1586102068408912@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1586102068408912@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 1586102068408912@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 2594092253257444@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293351044289261989247090256791408669312936346957045563392471156583000481243746043459046470739084604345904647073908(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 800619775273621@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1667085474426996@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1667085474426996@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 1667085474426996@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 2764068538698611@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293359049701615920947083266605587520412936346957045563392471099426169385253246044259587706132254604425958770613225(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 229051464313716@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1747139597966313@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1747139597966313@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 1747139597966313@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 2065049956583721@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293366960980136321647069888702920173412936346957045563392470920137490578001446045050715558172324604505071555817232(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 2939764303611694@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1826252383170320@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1826252383170320@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 1826252383170320@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 727259689849021@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293374776933413746147070534597199472292936346957045563392470920137490578001446045832310885914774604583231088591477(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 2939764303611694@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1904411915944565@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1904411915944565@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 1904411915944565@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 791849117778909@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293382496384394380247085730522854354312936346957045563392471099426169385253246046604255983978184604660425598397818(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 229051464313716@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1981606425750906@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1981606425750906@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 1981606425750906@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 2311441683267111@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293390118170557300547094858808826994162936346957045563392471156583000481243746047366434600270214604736643460027021(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 800619775273621@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2057824287380109@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2057824287380109@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 2057824287380109@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 3224270280531096@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293397641144089546147094931883414183232936346957045563392471151066287199307946048118731953494774604811873195349477(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 745452642454263@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2133054022702565@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2133054022702565@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 2133054022702565@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 3231577739250003@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293405064172058974647099913397804098852936346957045563392471178690606682385846048861034750437624604886103475043762(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1021695837285042@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2207284302396850@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2207284302396850@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 2207284302396850@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 3729729178241565@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293412386136584878047109222484465326322936346957045563392471244950164099472246049593231203027964604959323120302796(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1684291411455906@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2280503947655884@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2280503947655884@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 2280503947655884@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 157038216993816@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293419605935006330847109224850696483692936346957045563392471238465298401121646050315211045173244605031521104517324(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1619442754472400@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2352701931870412@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2352701931870412@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 2352701931870412@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 157274840109553@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293426722480048247447099815777549627012936346957045563392471160781466711185646051026865549364904605102686554936490(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 842604437573040@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2423867382289578@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2423867382289578@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 2423867382289578@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 3719967152794381@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293433734699985121247102358595968182702936346957045563392471171789486729365646051728087543052284605172808754305228(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 952684637754840@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2493989581658316@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2493989581658316@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 2493989581658316@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 3974248994649950@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293440641538802422647113685149868441272936346957045563392471277089801774928046052418771424782424605241877142478242(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2005687788210464@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2563057969831330@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2563057969831330@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 2563057969831330@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 603304757305311@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293447441956355631147116896465589577872936346957045563392471311426921193544246053098813180103274605309881318010327(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2349058982396626@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2631062145363415@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2631062145363415@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 2631062145363415@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 924436329418971@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293454134928526877047113586787343615322936346957045563392471263663316725817246053768110397227864605376811039722786(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1871422937719356@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2697991867075874@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2697991867075874@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 2697991867075874@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 593468504822716@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293460719447379170147113536572308566772936346957045563392471257264991352683046054426562282457174605442656228245717(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1807439683988014@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2763837055598805@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2763837055598805@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 2763837055598805@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 588447001317861@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293467194521308191147116727427803982432936346957045563392471290889645510386146055074069675359274605507406967535927(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2143686225565045@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2828587794889015@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2828587794889015@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 2828587794889015@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 907532550859427@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293473559175191623247113392606445266902936346957045563392471244555225336808346055710535063702484605571053506370248(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1680342023829267@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2892234333723336@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2892234333723336@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 2892234333723336@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 574050414987874@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293479812450536002947101581097396888902936346957045563392471133385806805120846056335862598140454605633586259814045(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 568647838512392@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2954767087167133@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2954767087167133@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 2954767087167133@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 3896499137520570@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293485953405621064447102761873585019992936346957045563392471136315280683465046056949958106646604605694995810664660(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 597942577295834@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3016176638017748@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3016176638017748@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 3016176638017748@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 4014576756333679@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293491981115641560447115564433486584702936346957045563392471255333590645738946057552729108696204605755272910869620(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1788125676918573@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3076453738222708@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3076453738222708@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 3076453738222708@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 791233119119654@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293497894672846533247120640844086754082936346957045563392471310317953995019146058144084829193484605814408482919348(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2337969310411375@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3135589310272436@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3135589310272436@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 3135589310272436@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1298874179136592@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293503693186676019747118768318286521392936346957045563392471283251778802778446058723936212142134605872393621214213(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2067307558488968@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3193574448567301@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3193574448567301@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 3193574448567301@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1111621599113323@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293509375783895165747120420902317382852936346957045563392471297632964889692946059292195934056734605929219593405673(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2211119419358113@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3250400420758761@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3250400420758761@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 3250400420758761@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1276880002199469@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293514941608725732247125927257194372112936346957045563392471356354536056559246059848778417113384605984877841711338(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2798335131026776@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3306058669064426@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3306058669064426@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 3306058669064426@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1827515489898395@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293520389822974972547123882185627028282936346957045563392471327872570645347946060393599842037414606039359984203741(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2513515476914663@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3360540811556829@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3360540811556829@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 3360540811556829@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1623008333164012@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293525719606161860847114925472903038952936346957045563392471221253657436840246060926578160726244606092657816072624(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1447326344829586@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3413838643425712@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3413838643425712@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 3413838643425712@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 727337060765079@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293530930155640653547114814587534988872936346957045563392471216109666579491646061447633108605514606144763310860551(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1395886436256100@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3465944138213639@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3465944138213639@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 3465944138213639@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 716248523960071@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293536020686721765147123492261239859082936346957045563392471309818115688209646061956686216716674606195668621671667(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2332970927343280@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3516849449024755@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3516849449024755@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 3516849449024755@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1584015894447092@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293540990432789939247125253213522697222936346957045563392471325262254241262646062453660823534084606245366082353408(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2487412312873810@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3566546909706496@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3566546909706496@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 3566546909706496@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1760111122730906@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293545838645419698247119553664202355442936346957045563392471257853865585950846062938482086509984606293848208650998(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1813328426320692@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3615029036004086@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3615029036004086@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 3615029036004086@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1190156190696728@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293550564594488053047117675000302628262936346957045563392471233475809302312946063411076993345464606341107699334546(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1569547863484313@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3662288526687634@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3662288526687634@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 3662288526687634@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1002289800724010@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293555167568284457547119243173163150402936346957045563392471247272088920982846063871374372985914606387137437298591(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1707510659671012@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3708318264651679@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3708318264651679@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 3708318264651679@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1159107086776224@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293559646873617988947114034634386729452936346957045563392471187082876948144046064319304906339054606431930490633905(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1105618539942624@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3753111317986993@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3753111317986993@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 3753111317986993@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 638253209134129@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293564001835921740147099872069564777412936346957045563392471068809302493732846064754801136714174606475480113671417(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 4426482422769008@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3796660941024505@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3796660941024505@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 3796660941024505@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 3725596354309421@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293568231799354407247100291444327725222936346957045563392471068809302493732846065177797479980884606517779747998088(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 4426482422769008@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3838960575351176@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3838960575351176@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 3838960575351176@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 3767533830604202@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293572336126899056047114824855497873792936346957045563392471187082876948144046065588230234445764606558823023444576(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1105618539942624@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3880003850797664@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3880003850797664@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 3880003850797664@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 717275320248563@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293576314200459055447120701385210217022936346957045563392471247272088920982846065986037590445704606598603759044570(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1707510659671012@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3919784586397658@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3919784586397658@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 3919784586397658@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1304928291482886@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293580165420951159647119670850287483672936346957045563392471233475809302312946066371159639656124606637115963965612(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1569547863484313@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3958296791318700@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3958296791318700@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 3958296791318700@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1201874799209551@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293583889208395728547122222225893110902936346957045563392471257853865585950846066743538384113014606674353838411301(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1813328426320692@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3995534665764389@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3995534665764389@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 3995534665764389@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1457012359772274@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293587485002004070047128861927833768062936346957045563392471325262254241262646067103117744947164606710311774494716(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2487412312873810@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4031492601847804@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4031492601847804@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4031492601847804@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2120982553837990@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293590952260262893247127661632512485262936346957045563392471309818115688209646067449843570829484606744984357082948(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2332970927343280@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4066165184436036@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4066165184436036@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4066165184436036@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2000953021709710@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293594290461015857847118964526133842392936346957045563392471216109666579491646067783663646125944606778366364612594(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1395886436256100@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4099547191965682@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4099547191965682@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4099547191965682@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1131242383845423@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293597499101542209447119667840105646322936346957045563392471221253657436840246068104527698761104606810452769876110(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1447326344829586@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4131633597229198@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4131633597229198@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4131633597229198@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1201573781025816@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293600577698632486847130129272402206592936346957045563392471327872570645347946068412387407788844606841238740778884(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2513515476914663@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4162419568131972@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4162419568131972@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4162419568131972@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2247717010681843@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293603525788661292447133108578315642072936346957045563392471356354536056559246068707196410669404606870719641066940(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2798335131026776@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4191900468420028@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4191900468420028@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4191900468420028@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2545647602025391@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293606342927657111647127649643557702312936346957045563392471297632964889692946068988910310251324606898891031025132(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2211119419358113@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4220071858378220@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4220071858378220@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4220071858378220@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1999754126231415@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293609028691369174147126452725005403112936346957045563392471283251778802778446069257486681457574606925748668145757(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2067307558488968@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4246929495498845@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4246929495498845@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4246929495498845@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1880062271001495@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293611582675331343747129276206582916762936346957045563392471310317953995019146069512885077674534606951288507767453(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2337969310411375@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4272469335120541@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4272469335120541@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4272469335120541@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2162410428752860@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293614004494923030147124088032903306642936346957045563392471255333590645738946069755067036843174606975506703684317(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1788125676918573@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4296687531037405@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4296687531037405@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4296687531037405@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1643593060791848@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293616293785427110847112589271042277032936346957045563392471136315280683465046069983996087251244606998399608725124(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 597942577295834@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4319580436078212@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4319580436078212@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4319580436078212@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 493716874688887@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293618450202084856747112423743488478182936346957045563392471133385806805120846070199637753025834607019963775302583(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 568647838512392@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4341144602655671@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4341144602655671@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4341144602655671@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 477164119309002@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293620473420147851047123479083860110172936346957045563392471244555225336808346070401959559325264607040195955932526(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1680342023829267@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4361376783285614@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4361376783285614@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4361376783285614@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1582698156472201@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293622363134926895547128178824636181132936346957045563392471290889645510386146070590931037229714607059093103722971(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2143686225565045@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4380273931076059@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4380273931076059@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4380273931076059@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2052672234079297@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293624119061837895247124985429618646252936346957045563392471257264991352683046070766523728329684607076652372832968(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1807439683988014@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4397833200186056@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4397833200186056@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4397833200186056@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1733332732325809@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293625740936444716347125732540333429372936346957045563392471263663316725817246070928711189011794607092871118901179(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1871422937719356@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4414051946254267@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4414051946254267@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4414051946254267@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1808043803804121@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293627228514499008647130574589840389072936346957045563392471311426921193544246071077468994441024607107746899444102(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2349058982396626@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4428927726797190@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4428927726797190@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4428927726797190@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 2292248754500091@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293628581571976988947127267126443270032936346957045563392471277089801774928046071212774742239054607121277474223905(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 2005687788210464@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4442458301576993@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4442458301576993@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4442458301576993@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1961502414788187@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293629799905113178047116882376201167722936346957045563392471171789486729365646071334608055857964607133460805585796(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 952684637754840@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4454641632938884@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4454641632938884@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4454641632938884@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 923027390577956@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293630883330431087047115851864011336382936346957045563392471160781466711185646071442950587648864607144295058764886(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 842604437573040@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4465475886117974@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4465475886117974@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4465475886117974@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 819976171594822@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293631831684770848047123651835418094472936346957045563392471238465298401121646071537786021624964607153778602162496(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1619442754472400@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4474959429515584@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4474959429515584@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4474959429515584@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1599973312270631@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293632644825313786047124354122254863102936346957045563392471244950164099472246071619100075918764607161910007591876(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1684291411455906@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4483090834944964@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4483090834944964@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4483090834944964@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1670201995947494@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293633322629603926047117784831990792512936346957045563392471178690606682385846071686880504932764607168688050493276(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 1021695837285042@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4489868877846364@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4489868877846364@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4489868877846364@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 1013272969540435@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293633864995566435147115058218167597062936346957045563392471151066287199307946071741117101183674607174111710118367(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 745452642454263@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4495292537471455@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4495292537471455@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4495292537471455@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 740611587220890@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293634271841522994447115633339319911902936346957045563392471156583000481243746071781801696839604607178180169683960(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 800619775273621@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4499360997037048@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4499360997037048@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4499360997037048@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 798123702452374@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293634543106204099347109934598966035842936346957045563392471099426169385253246071808928164950094607180892816495009(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1046@11 > e0, and[1046@11 = e0, 229051464313716@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4502073643848097@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4502073643848097@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4502073643848097@52 <= mr ] ], 
        or[ 1046@11 > er, and[1046@11 = er, 228249667064768@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main293634678748758286647092012347865575162936346957045563392470920137490578001446071822492420368824607182249242036882(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 652@11 < e0, and[652@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 2939764303611694@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4503430069389970@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4503430069389970@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 651@11 < er, and[651@11 = er, 4503430069389970@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 2939624184389196@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main314608300046934208446760432385432145183175037737296199680470465265987066311445782276819731598124578227681973159812(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 2894648895865290@52 >= m0 ] ] ,
        or[ 1016@11 < e1, and[1016@11 = e1, 2570460564735876@52 <= m1 ] ], 
        or[ 1016@11 > e1, and[1016@11 = e1, 2570460564735876@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 698@11 < er, and[698@11 = er, 2570460564735876@52 <= mr ] ], 
        or[ 1038@11 > er, and[1038@11 = er, 1306825332639670@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main315332061938872058946847153654698360153175037737296199680470640668468808467345854653008925383174585465300892538317(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 145074085916353@52 >= m0 ] ] ,
        or[ 1018@11 < e1, and[1018@11 = e1, 800880229373389@52 <= m1 ] ], 
        or[ 1018@11 > e1, and[1018@11 = e1, 800880229373389@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 700@11 < er, and[700@11 = er, 800880229373389@52 <= mr ] ], 
        or[ 1040@11 > er, and[1040@11 = er, 971753004520175@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main315685338897711945646887975505615823923175037737296199680470690914173519743245889980704809371844588998070480937184(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 647531133029112@52 >= m0 ] ] ,
        or[ 1018@11 < e1, and[1018@11 = e1, 4333649817772256@52 <= m1 ] ], 
        or[ 1018@11 > e1, and[1018@11 = e1, 4333649817772256@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 700@11 < er, and[700@11 = er, 4333649817772256@52 <= mr ] ], 
        or[ 1041@11 > er, and[1041@11 = er, 550338468896056@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main315870208706180815346906651233315966593175037737296199680470680006202886660045908467685656258814590846768565625881(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 538451426698280@52 >= m0 ] ] ,
        or[ 1019@11 < e1, and[1019@11 = e1, 1678748275090457@52 <= m1 ] ], 
        or[ 1019@11 > e1, and[1019@11 = e1, 1678748275090457@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 701@11 < er, and[701@11 = er, 1678748275090457@52 <= mr ] ], 
        or[ 1041@11 > er, and[1041@11 = er, 2417911238910323@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main316046208622649416546928781845149995313175037737296199680470700987053197142345926067677303118934592606767730311893(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 748259929803103@52 >= m0 ] ] ,
        or[ 1019@11 < e1, and[1019@11 = e1, 3438747439776469@52 <= m1 ] ], 
        or[ 1019@11 > e1, and[1019@11 = e1, 3438747439776469@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 701@11 < er, and[701@11 = er, 3438747439776469@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 127372794942699@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main316187211981618930346945160601646995183175037737296199680470758058404410333345940168013200070314594016801320007031(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1318973441935013@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 345181402101111@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 345181402101111@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 702@11 < er, and[702@11 = er, 345181402101111@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 1765248444642686@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main316274680658770287446954988268321460323175037737296199680470746405678025227545948914880915206024594891488091520602(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1202446178083955@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 1219868173614682@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 1219868173614682@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 702@11 < er, and[702@11 = er, 1219868173614682@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 2748015112089200@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main316361804575622737746954753038294788023175037737296199680470669415618988061045957627272600451054595762727260045105(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 432545587712290@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 2091107342139185@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 2091107342139185@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 702@11 < er, and[702@11 = er, 2091107342139185@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 2724492109421970@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main316448531251986542546965206168945067783175037737296199680470675134170940577945966299940236831534596629994023683153(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 489731107237459@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 2958374105777233@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 2958374105777233@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 702@11 < er, and[702@11 = er, 2958374105777233@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 3769805174449946@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main316534808446954779346982100674733672783175037737296199680470766481056076926145974927659733655214597492765973365521(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1403199958600941@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 3821146055459601@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 3821146055459601@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 702@11 < er, and[702@11 = er, 3821146055459601@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 955656125939950@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main316611818997258590246990393137968894843175037737296199680470792645878235139645982628714764036304598262871476403630(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1664848180183076@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 87651931127214@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 87651931127214@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 703@11 < er, and[703@11 = er, 87651931127214@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 1784902449462156@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main316654430309140767846990951039608483173175037737296199680470745266424580994045986889845952254064598688984595225406(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1191053643641620@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 513765049948990@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 513765049948990@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 703@11 < er, and[703@11 = er, 513765049948990@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 1840692613420989@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main316696739393735918646995116374582068303175037737296199680470735461077141609445991120754411769144599112075441176914(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1093000169247774@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 936855895900498@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 936855895900498@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 703@11 < er, and[703@11 = er, 936855895900498@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 2257226110779502@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main316738720765633521047003686327671958893175037737296199680470761228398019918045995318891601529384599531889160152938(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1350673378030860@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 1356669614876522@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 1356669614876522@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 703@11 < er, and[703@11 = er, 1356669614876522@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 3114221419768561@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main316780349136824928647002917712757919893175037737296199680470716885716589222045999481728720670144599948172872067014(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 907246563723900@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 1772953326790598@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 1772953326790598@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 703@11 < er, and[703@11 = er, 1772953326790598@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 3037359928364661@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main316821599431935920746993023158012799383175037737296199680470607638914422291946003606758231769354600360675823176935(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 4318378169425095@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 2185456277900519@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 2185456277900519@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 703@11 < er, and[703@11 = er, 2185456277900519@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 2047904453852610@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main316862446803331170346997023897791223633175037737296199680470607638914422291946007691495371294314600769149537129431(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 4318378169425095@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 2593929991853015@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 2593929991853015@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 703@11 < er, and[703@11 = er, 2593929991853015@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 2447978431695035@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main316902866646081530647017608839456541583175037737296199680470716885716589222046011733479646330344601173347964633034(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 907246563723900@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 2998128419356618@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 2998128419356618@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 703@11 < er, and[703@11 = er, 2998128419356618@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 2872970856334@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main316942834612785123947023899697574408973175037737296199680470761228398019918046015730276316689674601573027631668967(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1350673378030860@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 3397808086392551@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 3397808086392551@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 703@11 < er, and[703@11 = er, 3397808086392551@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 631958782643073@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main316982326628233306547024093130595947803175037737296199680470735461077141609446019679477861507934601967947786150793(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1093000169247774@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 3792728240874377@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 3792728240874377@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 703@11 < er, and[703@11 = er, 3792728240874377@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 651302084796956@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317021318903912674247027461501372260023175037737296199680470745266424580994046023578705429444704602357870542944470(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1191053643641620@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 4182650997668054@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 4182650997668054@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 703@11 < er, and[703@11 = er, 4182650997668054@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 988139162428178@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317056600859608645547034665118256512723175037737296199680470792645878235139646027106900999041834602710690099904183(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1664848180183076@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 31870927257271@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 31870927257271@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 31870927257271@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 1708500850853448@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317075562184032500747034517035883274643175037737296199680470766481056076926146029003033441427354602900303344142735(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1403199958600941@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 221484171495823@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 221484171495823@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 221484171495823@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 1693692613529640@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317094238887076538547027003873975023923175037737296199680470675134170940577946030870703745831134603087070374583113(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 489731107237459@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 408251201936201@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 408251201936201@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 408251201936201@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 942376422704568@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317112619718593212147028394800890666333175037737296199680470669415618988061046032708786897498494603270878689749849(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 432545587712290@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 592059517102937@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 592059517102937@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 592059517102937@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 1081469114268809@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317130693606656919447039395901621943633175037737296199680470746405678025227546034516175703869224603451617570386922(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1202446178083955@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 772798397740010@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 772798397740010@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 772798397740010@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 2181579187396539@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317148449664233317147043056759131232463175037737296199680470758058404410333346036291781461508994603629178146150899(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1318973441935013@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 950358973503987@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 950358973503987@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 950358973503987@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 2547664938325422@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317165877195737262847038177598968097183175037737296199680470700987053197142346038034534611903564603803453461190356(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 748259929803103@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1124634288543444@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1124634288543444@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 1124634288543444@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 2059748922011894@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317182965703475436147037468743663677273175037737296199680470680006202886660046039743385385720894603974338538572089(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 538451426698280@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1295519365925177@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1295519365925177@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 1295519365925177@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 1988863391569903@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317199704893969755847040787919236648463175037737296199680470690914173519743246041417304435152864604141730443515286(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 647531133029112@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1462911270868374@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1462911270868374@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 1462911270868374@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 2320780948867022@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317216084684157786847035821952828043743175037737296199680470640668468808467346043055283453955964604305528345395596(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 145074085916353@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1626709172748684@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1626709172748684@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 1626709172748684@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 1824184308006550@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317232095207466399747024211724032802083175037737296199680470465265987066311446044656335784817254604465633578481725(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 2894648895865290@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1786814405834813@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1786814405834813@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 1786814405834813@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 663161428482384@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317247726819755025547025495658686176703175037737296199680470465265987066311446046219497013679834604621949701367983(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 2894648895865290@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1943130528721071@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1943130528721071@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 1943130528721071@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 791554893819846@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317262970105124924947040661526547290623175037737296199680470640668468808467346047743825550669774604774382555066977(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 145074085916353@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2095563382420065@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2095563382420065@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 2095563382420065@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 2308141679931238@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317277815881590974547049722103985566243175037737296199680470690914173519743246049228403197274734604922840319727473(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 647531133029112@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2244021147080561@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2244021147080561@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 2244021147080561@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 3214199423758800@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317292255206612550347049704361837686133175037737296199680470680006202886660046050672335699432314605067233569943231(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 538451426698280@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2388414397296319@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2388414397296319@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 2388414397296319@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 3212425208970789@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317306279382480180547054550558984624943175037737296199680470700987053197142346052074753286195334605207475328619533(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 748259929803103@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2528656155972621@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2528656155972621@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 2528656155972621@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 3697044923664670@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317319879961554720247063918295031329673175037737296199680470758058404410333346053434811193649304605343481119364930(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1318973441935013@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2664661946718018@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2664661946718018@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 2664661946718018@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 130218900964647@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317333048751355893247063825168713874093175037737296199680470746405678025227546054751690173766604605475169017376660(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1202446178083955@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2796349844729748@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2796349844729748@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 2796349844729748@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 120906269219089@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317345777819497136247053949964301288343175037737296199680470669415618988061046056024596987890904605602459698789090(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 432545587712290@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2923640526142178@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2923640526142178@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 2923640526142178@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 3636985455331010@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317358059498463771347056254777169366813175037737296199680470675134170940577946057252764884554414605725276488455441(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 489731107237459@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3046457315808529@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3046457315808529@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 3046457315808529@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 3867466742138857@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317369886390231630647067867954769466373175037737296199680470766481056076926146058435454061340344605843545406134034(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1403199958600941@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3164726233487122@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3164726233487122@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 3164726233487122@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 525184874778317@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317381251370723349047070873824449268233175037737296199680470792645878235139646059571952110512184605957195211051218(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1664848180183076@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3278376038404306@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3278376038404306@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 3278376038404306@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 825771842758503@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317392147594099642547067469264023435893175037737296199680470745266424580994046060661574448141534606066157444814153(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1191053643641620@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3387338272167241@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3387338272167241@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 3387338272167241@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 485315800175269@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317402568496882985147067257746938147553175037737296199680470735461077141609446061703664726475794606170366472647579(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1093000169247774@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3491547300000667@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3491547300000667@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 3491547300000667@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 464164091646435@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317412507801911202847070190966399534253175037737296199680470761228398019918046062697595229297564606269759522929756(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1350673378030860@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3590940350282844@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3590940350282844@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 3590940350282844@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 757486037785105@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317421959522118601247066773790931681513175037737296199680470716885716589222046063642767250037404606364276725003740(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 907246563723900@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3685457552356828@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3685457552356828@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 3685457552356828@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 415768490999831@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317430917964142349947053628133397642933175037737296199680470607638914422291946064538611452412274606453861145241227(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 4318378169425095@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3775041972594315@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3775041972594315@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 3775041972594315@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 3604802364966469@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317439377731751951547054456713735517363175037737296199680470607638914422291946065384588213372434606538458821337243(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 4318378169425095@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3859639648690331@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3859639648690331@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 3859639648690331@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 3687660398753912@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317447333729099729147068298081971691653175037737296199680470716885716589222046066180187948150194606618018794815019(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 907246563723900@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3939199622168107@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3939199622168107@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 3939199622168107@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 568197595000845@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317454781163790374247072938544134827863175037737296199680470761228398019918046066924931417214704606692493141721470(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1350673378030860@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4013673969074558@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4013673969074558@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 4013673969074558@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 1032243811314466@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317461715549767706947070932833663590743175037737296199680470735461077141609446067618370014947974606761837001494797(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1093000169247774@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4083017828847885@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4083017828847885@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 4083017828847885@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 831672764190754@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317468132710016907647072273297737675413175037737296199680470745266424580994046068260086039868044606826008603986804(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1191053643641620@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4147189431339892@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4147189431339892@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 4147189431339892@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 965719171599221@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317474028779080595447077227548675703323175037737296199680470792645878235139646068849692946236824606884969294623682(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1664848180183076@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4206150121976770@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4206150121976770@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 4206150121976770@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 1461144265402012@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317479400205387234647075049722816606973175037737296199680470766481056076926146069386835576900744606938683557690074(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1403199958600941@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4259864385043162@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4259864385043162@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 4259864385043162@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 1243361679492377@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317484243753390468547066430731702129853175037737296199680470675134170940577946069871190377224134606987119037722413(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 489731107237459@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4308299865075501@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4308299865075501@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 4308299865075501@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 381462568044665@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317488556505518091947066107624225030523175037737296199680470669415618988061046070302465589986474607030246558998647(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 432545587712290@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4351427386351735@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4351427386351735@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 4351427386351735@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 349151820334732@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317492335863929487547073915980905967033175037737296199680470746405678025227546070680401431126034607068040143112603(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1202446178083955@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4389220970465691@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4389220970465691@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 4389220970465691@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 1129987488428383@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317495579552080467347075276139741434713175037737296199680470758058404410333346071004770246224014607100477024622401(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 1318973441935013@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4421657851975489@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4421657851975489@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 4421657851975489@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 1266003371975151@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317498285616094578747069778707941461513175037737296199680470700987053197142346071275376647635154607127537664763515(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 748259929803103@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4448718492116603@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4448718492116603@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 4448718492116603@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 716260191977831@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317500452425940045747067814700312360153175037737296199680470680006202886660046071492057632181854607149205763218185(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 538451426698280@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4470386590571273@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4470386590571273@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 4470386590571273@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 519859429067695@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317502078676411639747068994478886697913175037737296199680470690914173519743246071654682679341254607165468267934125(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 647531133029112@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4486649095287213@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4486649095287213@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 4486649095287213@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 637837286501471@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317503163387916886147064035346751328153175037737296199680470640668468808467346071763153829865894607176315382986589(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1045@11 > e0, and[1045@11 = e0, 145074085916353@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4497496210339677@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4497496210339677@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 4497496210339677@52 <= mr ] ], 
        or[ 1045@11 > er, and[1045@11 = er, 141924072964495@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main317503705907066133947046521027961557623175037737296199680470465265987066311446071817405744790674607181740574479067(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 705@11 < e0, and[705@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 2894648895865290@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4502921401832155@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4502921401832155@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 704@11 < er, and[704@11 = er, 4502921401832155@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 2894091821357938@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main338927684768362662246759732270817699983413728517546835968470006046704813853445827307489368080624582730748936808062(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1043@11 > e0, and[1043@11 = e0, 2806055700711206@52 >= m0 ] ] ,
        or[ 1017@11 < e1, and[1017@11 = e1, 2569927901013630@52 <= m1 ] ], 
        or[ 1017@11 > e1, and[1017@11 = e1, 2569927901013630@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 752@11 < er, and[752@11 = er, 2569927901013630@52 <= mr ] ], 
        or[ 1038@11 > er, and[1038@11 = er, 1236813871195150@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main339651140486942565446845244411489408673413728517546835968470173004719094361445899653061226070944589965306122607094(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1043@11 > e0, and[1043@11 = e0, 4475635843516286@52 >= m0 ] ] ,
        or[ 1019@11 < e1, and[1019@11 = e1, 797285832071670@52 <= m1 ] ], 
        or[ 1019@11 > e1, and[1019@11 = e1, 797285832071670@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 754@11 < er, and[754@11 = er, 797285832071670@52 <= mr ] ], 
        or[ 1040@11 > er, and[1040@11 = er, 780828683625027@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main340003113814939726246885140039797214313413728517546835968470212570985411604145934850394025787024593485039402578702(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 367698879318217@52 >= m0 ] ] ,
        or[ 1019@11 < e1, and[1019@11 = e1, 4317019112043278@52 <= m1 ] ], 
        or[ 1019@11 > e1, and[1019@11 = e1, 4317019112043278@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 754@11 < er, and[754@11 = er, 4317019112043278@52 <= mr ] ], 
        or[ 1041@11 > er, and[1041@11 = er, 266791887035095@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main340187367022547757446901399227748298003413728517546835968470193111908905883445953275714786590144595327571478659014(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 173108114261010@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 1655951560753094@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 1655951560753094@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 755@11 < er, and[755@11 = er, 1655951560753094@52 <= mr ] ], 
        or[ 1041@11 > er, and[1041@11 = er, 1892710682143464@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main340360807314556912346921320737387573973413728517546835968470204013350230632145970619743987505634597061974398750563(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 282122527508497@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 3390354480844643@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 3390354480844643@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 755@11 < er, and[755@11 = er, 3390354480844643@52 <= mr ] ], 
        or[ 1041@11 > er, and[1041@11 = er, 3884861646071061@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main340502238856544011946938171284364467713413728517546835968470247530553757930045984762898186215594598476289818621559(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 717294562781476@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 301070273345143@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 301070273345143@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 756@11 < er, and[756@11 = er, 301070273345143@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 1066316716389939@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main340586850654141798546945740927322560683413728517546835968470229684753730898445993224077945994254599322407794599425(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 538836562511160@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 1147188249323009@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 1147188249323009@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 756@11 < er, and[756@11 = er, 1147188249323009@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 1823281012199236@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main340670101127445033546944454888164590623413728517546835968470136204012632875946001549125276317754600154912527631775(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1043@11 > e0, and[1043@11 = e0, 4107628778901431@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 1979692982355359@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 1979692982355359@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 756@11 < er, and[756@11 = er, 1979692982355359@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 1694677096402230@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main340751789718771649046952264631217957973413728517546835968470136204012632875946009717984408979304600971798440897930(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1043@11 > e0, and[1043@11 = e0, 4107628778901431@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 2796578895621514@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 2796578895621514@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 756@11 < er, and[756@11 = er, 2796578895621514@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 2475651401738965@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main340831719633150063846972850846001192313413728517546835968470229684753730898446017710975846820784601771097584682078(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 538836562511160@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 3595878039405662@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 3595878039405662@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 756@11 < er, and[756@11 = er, 3595878039405662@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 30673252691903@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main340909698312415506646978975503363546113413728517546835968470247530553757930046025508843773365064602550884377336506(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 717294562781476@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 4375664832060090@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 4375664832060090@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 756@11 < er, and[756@11 = er, 4375664832060090@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 643138988927283@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main340954014845523024346978715116446592553413728517546835968470204013350230632146029940497084116834602994049708411683(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 282122527508497@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 315230535764771@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 315230535764771@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 757@11 < er, and[757@11 = er, 315230535764771@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 617100297231927@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main340990773740470755146981365849730541793413728517546835968470193111908905883446033616386578889914603361638657888991(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 173108114261010@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 682819485242079@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 682819485242079@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 757@11 < er, and[757@11 = er, 682819485242079@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 882173625626851@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main341026283181626591346987447651769830903413728517546835968470212570985411604146037167330694473534603716733069447353(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 367698879318217@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1037913896800441@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1037913896800441@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 757@11 < er, and[757@11 = er, 1037913896800441@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 1490353829555762@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main341060457623636528946986158044801273463413728517546835968470173004719094361446040584774895467294604058477489546729(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1043@11 > e0, and[1043@11 = e0, 4475635843516286@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1379658316899817@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1379658316899817@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 757@11 < er, and[757@11 = er, 1379658316899817@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 1361393132700018@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main341093214737276438346977911154368224933413728517546835968470006046704813853446043860486259458234604386048625945823(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1043@11 > e0, and[1043@11 = e0, 2806055700711206@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1707229453298911@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1707229453298911@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 757@11 < er, and[757@11 = er, 1707229453298911@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 536704089395165@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main341124475607790376646980448082688006523413728517546835968470006046704813853446046986573310852064604698657331085206(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1043@11 > e0, and[1043@11 = e0, 2806055700711206@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2019838158438294@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2019838158438294@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 757@11 < er, and[757@11 = er, 2019838158438294@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 790396921373324@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main341154164925003147046995499682534771233413728517546835968470173004719094361446049955505032129104604995550503212910(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1043@11 > e0, and[1043@11 = e0, 4475635843516286@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2316731330565998@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2316731330565998@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 757@11 < er, and[757@11 = er, 2316731330565998@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 2295556906049795@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main341182211164749106747004313532713585693413728517546835968470212570985411604146052760129006725074605276012900672507(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 367698879318217@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2597193728025595@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2597193728025595@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 757@11 < er, and[757@11 = er, 2597193728025595@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 3176941923931241@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main341208546761180147447003980221702695523413728517546835968470193111908905883446055393688649829144605539368864982914(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 173108114261010@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2860549692336002@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2860549692336002@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 757@11 < er, and[757@11 = er, 2860549692336002@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 3143610822842224@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main341233108269537740847008372805697448893413728517546835968470204013350230632146057849839485588484605784983948558848(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 282122527508497@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3106164775911936@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3106164775911936@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 757@11 < er, and[757@11 = er, 3106164775911936@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 3582869222317561@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main341255836518996919447017970434642336103413728517546835968470247530553757930046060122664431506344606012266443150634(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 717294562781476@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3333447270503722@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3333447270503722@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 757@11 < er, and[757@11 = er, 3333447270503722@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 39032489435786@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main341276676755213976547017584378894573473413728517546835968470229684753730898446062206688053212054606220668805321205(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 538836562511160@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3541849632674293@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3541849632674293@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 757@11 < er, and[757@11 = er, 3541849632674293@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 426914659523@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main341295578772234476247006232807376619943413728517546835968470136204012632875946064096889755262024606409688975526202(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1043@11 > e0, and[1043@11 = e0, 4107628778901431@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3730869802879290@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3730869802879290@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 757@11 < er, and[757@11 = er, 3730869802879290@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 3368869390234666@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main341312497033443794847007850258122296853413728517546835968470136204012632875946065788715876193884606578871587619388(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1043@11 > e0, and[1043@11 = e0, 4107628778901431@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3900052414972476@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3900052414972476@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 757@11 < er, and[757@11 = er, 3900052414972476@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 3530614464802357@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main341327390781268814647020423466085621413413728517546835968470229684753730898446067278090658695864606727809065869586(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 538836562511160@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4048989893222674@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4048989893222674@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 757@11 < er, and[757@11 = er, 4048989893222674@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 284335633764317@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main341340224135366486747022861842099462653413728517546835968470247530553757930046068561426068463074606856142606846307(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 717294562781476@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4177323434199395@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4177323434199395@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 757@11 < er, and[757@11 = er, 4177323434199395@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 528173235148441@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main341350966179062720947019238506477153383413728517546835968470204013350230632146069635630438086494606963563043808649(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 282122527508497@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4284743871161737@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4284743871161737@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 757@11 < er, and[757@11 = er, 4284743871161737@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 165839672917514@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main341359591033833360947018622669252441283413728517546835968470193111908905883446070498115915150494607049811591515049(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 173108114261010@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4370992418868137@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4370992418868137@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 757@11 < er, and[757@11 = er, 4370992418868137@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 104255950446304@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main341366077921647816347020890754222371333413728517546835968470212570985411604146071146804696596034607114680469659603(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1044@11 > e0, and[1044@11 = e0, 367698879318217@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4435861297012691@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4435861297012691@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 757@11 < er, and[757@11 = er, 4435861297012691@52 <= mr ] ], 
        or[ 1044@11 > er, and[1044@11 = er, 331064447439309@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main341370411215025157847017057175634430053413728517546835968470173004719094361446071580134034330184607158013403433018(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1043@11 > e0, and[1043@11 = e0, 4475635843516286@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4479194230786106@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4479194230786106@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 757@11 < er, and[757@11 = er, 4479194230786106@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 4451306216015677@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main341372580474682087747000582655166165253413728517546835968470006046704813853446071797060000023174607179706000002317(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 758@11 < e0, and[758@11 = e0, 0@52 <= m0 ] ], 
        or[ 1043@11 > e0, and[1043@11 = e0, 2806055700711206@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4500886827355405@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4500886827355405@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 757@11 < er, and[757@11 = er, 4500886827355405@52 <= mr ] ], 
        or[ 1043@11 > er, and[1043@11 = er, 2803854169189197@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main363246909714738997246758373723135051943652419297797472256469538602446651980645872322181499351244587232218149935124(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 811@11 < e0, and[811@11 = e0, 0@52 <= m0 ] ], 
        or[ 1042@11 > e0, and[1042@11 = e0, 2635212746462974@52 >= m0 ] ] ,
        or[ 1018@11 < e1, and[1018@11 = e1, 2567797486770196@52 <= m1 ] ], 
        or[ 1018@11 > e1, and[1018@11 = e1, 2567797486770196@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 806@11 < er, and[806@11 = er, 2567797486770196@52 <= mr ] ], 
        or[ 1038@11 > er, and[1038@11 = er, 1100959102930346@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main363969142176863877846841747875842241543652419297797472256469665510207701959145944545427711839304594454542771183930(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 811@11 < e0, and[811@11 = e0, 0@52 <= m0 ] ], 
        or[ 1042@11 > e0, and[1042@11 = e0, 3904290356962759@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 782922853278010@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 782922853278010@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 808@11 < er, and[808@11 = er, 782922853278010@52 <= mr ] ], 
        or[ 1040@11 > er, and[1040@11 = er, 431175118908314@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main364315918286935631546877976115548095363652419297797472256469705204415786874445979223038719014674597922303871901467(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 811@11 < e0, and[811@11 = e0, 0@52 <= m0 ] ], 
        or[ 1042@11 > e0, and[1042@11 = e0, 4301232437811912@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 4250683953995547@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 4250683953995547@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 808@11 < er, and[808@11 = er, 4250683953995547@52 <= mr ] ], 
        or[ 1040@11 > er, and[1040@11 = er, 4053999089493696@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main364497736698816918146892756066042434023652419297797472256469645760205133997745997404879907143334599740487990714333(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 811@11 < e0, and[811@11 = e0, 0@52 <= m0 ] ], 
        or[ 1042@11 > e0, and[1042@11 = e0, 3706790331283145@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 1565268445437917@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 1565268445437917@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 809@11 < er, and[809@11 = er, 1565268445437917@52 <= mr ] ], 
        or[ 1041@11 > er, and[1041@11 = er, 1028394511557066@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main364661064675317267246907644005570582553652419297797472256469645760205133997746013737677557178244601373767755717824(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 811@11 < e0, and[811@11 = e0, 0@52 <= m0 ] ], 
        or[ 1042@11 > e0, and[1042@11 = e0, 3706790331283145@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 3198548210441408@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 3198548210441408@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 809@11 < er, and[809@11 = er, 3198548210441408@52 <= mr ] ], 
        or[ 1041@11 > er, and[1041@11 = er, 2517188464371919@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main364804272439708875046927738004195570843652419297797472256469705204415786874446028058453996339024602805845399633902(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 811@11 < e0, and[811@11 = e0, 0@52 <= m0 ] ], 
        or[ 1042@11 > e0, and[1042@11 = e0, 4301232437811912@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 127026226986990@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 127026226986990@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 810@11 < er, and[810@11 = er, 127026226986990@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 22988699500252@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main364877768087420523746932557863086025523652419297797472256469665510207701959146035408018767503894603540801876750389(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 811@11 < e0, and[811@11 = e0, 0@52 <= m0 ] ], 
        or[ 1042@11 > e0, and[1042@11 = e0, 3904290356962759@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 861982704103477@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 861982704103477@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 810@11 < er, and[810@11 = er, 861982704103477@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 504974588545720@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main364946096386034396846930413454693069043652419297797472256469538602446651980646042240848628891204604224084862889120(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 811@11 < e0, and[811@11 = e0, 0@52 <= m0 ] ], 
        or[ 1042@11 > e0, and[1042@11 = e0, 2635212746462974@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1545265690242208@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1545265690242208@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 810@11 < er, and[810@11 = er, 1545265690242208@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 290533749250072@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main365008599296682795146935367231547761533652419297797472256469538602446651980646048491139693731034604849113969373103(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 811@11 < e0, and[811@11 = e0, 0@52 <= m0 ] ], 
        or[ 1042@11 > e0, and[1042@11 = e0, 2635212746462974@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2170294796726191@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2170294796726191@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 810@11 < er, and[810@11 = er, 2170294796726191@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 785911434719321@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main365064674882168608146950004926519634883652419297797472256469665510207701959146054098698242312334605409869824231233(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 811@11 < e0, and[811@11 = e0, 0@52 <= m0 ] ], 
        or[ 1042@11 > e0, and[1042@11 = e0, 3904290356962759@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2731050651584321@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2731050651584321@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 810@11 < er, and[810@11 = er, 2731050651584321@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 2249680931906656@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main365113783103949574246957993684612410683652419297797472256469705204415786874446059009520420408944605900952042040894(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 811@11 < e0, and[811@11 = e0, 0@52 <= m0 ] ], 
        or[ 1042@11 > e0, and[1042@11 = e0, 4301232437811912@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3222132869393982@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3222132869393982@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 810@11 < er, and[810@11 = er, 3222132869393982@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 3048556741184236@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main365155451023004657946956693167076774583652419297797472256469645760205133997746063176312325917314606317631232591731(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 811@11 < e0, and[811@11 = e0, 0@52 <= m0 ] ], 
        or[ 1042@11 > e0, and[1042@11 = e0, 3706790331283145@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3638812059944819@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3638812059944819@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 810@11 < er, and[810@11 = er, 3638812059944819@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 2918504987620626@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main365189277354495357346959776560310949393652419297797472256469645760205133997746066558945474987254606655894547498725(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 811@11 < e0, and[811@11 = e0, 0@52 <= m0 ] ], 
        or[ 1042@11 > e0, and[1042@11 = e0, 3706790331283145@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3977075374851813@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3977075374851813@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 810@11 < er, and[810@11 = er, 3977075374851813@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 3226844311038107@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main365214936332358063146967881743750427323652419297797472256469705204415786874446069124843261257834606912484326125783(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 811@11 < e0, and[811@11 = e0, 0@52 <= m0 ] ], 
        or[ 1042@11 > e0, and[1042@11 = e0, 4301232437811912@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4233665153478871@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4233665153478871@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 810@11 < er, and[810@11 = er, 4233665153478871@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 4037362654985900@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main365232180846609333546965640993635569433652419297797472256469665510207701959146070849294686384874607084929468638487(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 811@11 < e0, and[811@11 = e0, 0@52 <= m0 ] ], 
        or[ 1042@11 > e0, and[1042@11 = e0, 3904290356962759@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4406110295991575@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4406110295991575@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 810@11 < er, and[810@11 = er, 4406110295991575@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 3813287643500111@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main365240844823150118246953774254543724663652419297797472256469538602446651980646071715692340463344607171569234046334(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 811@11 < e0, and[811@11 = e0, 0@52 <= m0 ] ], 
        or[ 1042@11 > e0, and[1042@11 = e0, 2635212746462974@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4492750061399422@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4492750061399422@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 810@11 < er, and[810@11 = er, 4492750061399422@52 <= mr ] ], 
        or[ 1042@11 > er, and[1042@11 = er, 2626613734315634@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main387565495921788215646755813734924095273891110078048108544469056456221352039445917272999697910204591727299969791020(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 864@11 < e0, and[864@11 = e0, 0@52 <= m0 ] ], 
        or[ 1041@11 > e0, and[1041@11 = e0, 2317350120834058@52 >= m0 ] ] ,
        or[ 1019@11 < e1, and[1019@11 = e1, 2559279679255596@52 <= m1 ] ], 
        or[ 1019@11 > e1, and[1019@11 = e1, 2559279679255596@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 860@11 < er, and[860@11 = er, 2559279679255596@52 <= mr ] ], 
        or[ 1038@11 > er, and[1038@11 = er, 844960281834679@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main388282858302325530246834251083484041353891110078048108544469122652132913162845989009237751641664598900923775164166(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 864@11 < e0, and[864@11 = e0, 0@52 <= m0 ] ], 
        or[ 1041@11 > e0, and[1041@11 = e0, 2979309236445292@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 725704229887750@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 725704229887750@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 862@11 < er, and[862@11 = er, 725704229887750@52 <= mr ] ], 
        or[ 1039@11 > er, and[1039@11 = er, 4185095510458791@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main388609120783924997946862948504786835363891110078048108544469122652132913162846021635485911588434602163548591158843(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 864@11 < e0, and[864@11 = e0, 0@52 <= m0 ] ], 
        or[ 1041@11 > e0, and[1041@11 = e0, 2979309236445292@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 3988329045882427@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 3988329045882427@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 862@11 < er, and[862@11 = er, 3988329045882427@52 <= mr ] ], 
        or[ 1040@11 > er, and[1040@11 = er, 2551238013367696@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main388781698550969903046878943422617027003891110078048108544469056456221352039446038893262616078944603889326261607894(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 864@11 < e0, and[864@11 = e0, 0@52 <= m0 ] ], 
        or[ 1041@11 > e0, and[1041@11 = e0, 2317350120834058@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1210507088960982@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1210507088960982@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 863@11 < er, and[863@11 = er, 1210507088960982@52 <= mr ] ], 
        or[ 1040@11 > er, and[1040@11 = er, 4150729796386860@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main388906553797280339346890162779225398893891110078048108544469056456221352039446051378787247122574605137878724712257(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 864@11 < e0, and[864@11 = e0, 0@52 <= m0 ] ], 
        or[ 1041@11 > e0, and[1041@11 = e0, 2317350120834058@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2459059552065345@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2459059552065345@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 863@11 < er, and[863@11 = er, 2459059552065345@52 <= mr ] ], 
        or[ 1041@11 > er, and[1041@11 = er, 769065829853553@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main389004651934834628946903429489114957733891110078048108544469122652132913162846061188601002551534606118860100255153(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 864@11 < e0, and[864@11 = e0, 0@52 <= m0 ] ], 
        or[ 1041@11 > e0, and[1041@11 = e0, 2979309236445292@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3440040927608241@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3440040927608241@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 863@11 < er, and[863@11 = er, 3440040927608241@52 <= mr ] ], 
        or[ 1041@11 > er, and[1041@11 = er, 2095736818809437@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main389072223107220629846909043097857092413891110078048108544469122652132913162846067945718241151624606794571824115162(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 864@11 < e0, and[864@11 = e0, 0@52 <= m0 ] ], 
        or[ 1041@11 > e0, and[1041@11 = e0, 2979309236445292@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4115752651468250@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4115752651468250@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 863@11 < er, and[863@11 = er, 4115752651468250@52 <= mr ] ], 
        or[ 1041@11 > er, and[1041@11 = er, 2657097693022905@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main389106670592177898246905317174761275803891110078048108544469056456221352039446071390466736878464607139046673687846(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 864@11 < e0, and[864@11 = e0, 0@52 <= m0 ] ], 
        or[ 1041@11 > e0, and[1041@11 = e0, 2317350120834058@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4460227501040934@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4460227501040934@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 863@11 < er, and[863@11 = er, 4460227501040934@52 <= mr ] ], 
        or[ 1041@11 > er, and[1041@11 = er, 2284505383441244@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main411881532940154625146751253774093842944129800858298744832468550962654253427545961968899028188274596196889902818827(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 917@11 < e0, and[917@11 = e0, 0@52 <= m0 ] ], 
        or[ 1040@11 > e0, and[1040@11 = e0, 1766014077218435@52 >= m0 ] ] ,
        or[ 1020@11 < e1, and[1020@11 = e1, 2525269984912907@52 <= m1 ] ], 
        or[ 1020@11 > e1, and[1020@11 = e1, 2525269984912907@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 914@11 < er, and[914@11 = er, 2525269984912907@52 <= mr ] ], 
        or[ 1038@11 > er, and[1038@11 = er, 388964198809446@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main412579779083281428046817028347041775754129800858298744832468550962654253427546031793513340868564603179351334086856(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 917@11 < e0, and[917@11 = e0, 0@52 <= m0 ] ], 
        or[ 1040@11 > e0, and[1040@11 = e0, 1766014077218435@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 500532161439944@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 500532161439944@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 916@11 < er, and[916@11 = er, 500532161439944@52 <= mr ] ], 
        or[ 1039@11 > er, and[1039@11 = er, 2462821866232231@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main412828287151627510746844530061141866274129800858298744832468550962654253427546056644320175476834605664432017547683(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 917@11 < e0, and[917@11 = e0, 0@52 <= m0 ] ], 
        or[ 1040@11 > e0, and[1040@11 = e0, 1766014077218435@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 2985612844900771@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 2985612844900771@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 916@11 < er, and[916@11 = er, 2985612844900771@52 <= mr ] ], 
        or[ 1040@11 > er, and[1040@11 = er, 709393648870787@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main412962778749071275246853891576732205354129800858298744832468550962654253427546070093479919853284607009347991985328(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 917@11 < e0, and[917@11 = e0, 0@52 <= m0 ] ], 
        or[ 1040@11 > e0, and[1040@11 = e0, 1766014077218435@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 4330528819338416@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 4330528819338416@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 916@11 < er, and[916@11 = er, 4330528819338416@52 <= mr ] ], 
        or[ 1040@11 > er, and[1040@11 = er, 1645545207904695@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main436187465152087075546740507809925399744368491638549381120468017273886052298246005654317715070434600565431771507043(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 970@11 < e0, and[970@11 = e0, 0@52 <= m0 ] ], 
        or[ 1039@11 > e0, and[1039@11 = e0, 932726022577638@52 >= m0 ] ] ,
        or[ 1021@11 < e1, and[1021@11 = e1, 2390212226230627@52 <= m1 ] ], 
        or[ 1021@11 > e1, and[1021@11 = e1, 2390212226230627@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 968@11 < er, and[968@11 = er, 2390212226230627@52 <= mr ] ], 
        or[ 1037@11 > er, and[1037@11 = er, 3817967409335622@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main436780600633134624646797589232106280474368491638549381120468017273886052298246064967865819825344606496786581982534(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 970@11 < e0, and[970@11 = e0, 0@52 <= m0 ] ], 
        or[ 1039@11 > e0, and[1039@11 = e0, 932726022577638@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 3817967409335622@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 3817967409335622@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 969@11 < er, and[969@11 = er, 3817967409335622@52 <= mr ] ], 
        or[ 1039@11 > er, and[1039@11 = er, 518910372682703@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}


proc main460454427121780218946720982656283596294607182418800017408467473641321057484846045442712178021894604544271217802189(uint1 s0, uint11 e0, uint52 m0, uint1 s1, uint11 e1, uint52 m1, uint1 sr, uint11 er, uint52 mr) =
{ 
    true 
        && 
    and[
        or[ 1023@11 < e0, and[1023@11 = e0, 0@52 <= m0 ] ], 
        or[ 1038@11 > e0, and[1038@11 = e0, 0@52 >= m0 ] ] ,
        or[ 1022@11 < e1, and[1022@11 = e1, 1865452045155277@52 <= m1 ] ], 
        or[ 1022@11 > e1, and[1022@11 = e1, 1865452045155277@52 >= m1 ] ] 
    ]
}

(* we assume that r1 || r0 is the same as s0 || e0 || m0
   r0 and r1 are the actual input registers, but we specify the preconditions on s0, e0, and m0
*)
join t e0 m0;
join src0 s0 t;
spl r1 r0 src0 32;
adds carry t e0 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src0@uint64 src0 t;
split hi src0 src0 53;

assert true && or[src0 = 0@64, and[(2**52)@64 <= src0, src0 <= (2**53 - 1)@64]];

(* we assume that r3 || r2 is the same as s1 || e1 || m1
   r2 and r3 are the actual input registers, but we specify the preconditions on s1, e1, and m1
*)
join t e1 m1;
join src1 s1 t;
spl r3 r2 src1 32;
adds carry t e1 2047@uint11;
cmov t carry (2**52)@uint64 0@uint64;
or src1@uint64 src1 t;
split hi src1 src1 53;

assert true && or[src1 = 0@64, and[(2**52)@64 <= src1, src1 <= (2**53 - 1)@64]];

(* start constructing all the intermediate values *)
mulj r src0 src1;
assert true && or[r = 0@128, and[(2**104)@128 <= r, r <= ((2**106)@128 - (2**54)@128 + 1@128)]];

(* construct the multilimb of src0 in boolean and introduce the corresponding algebraic equations *)
split hi0 lo0 src0 25;
spl t lo0 lo0 32;
spl t hi0 hi0 32;
assert true && src0 = (uext lo0 32) + (uext hi0 32) * (2**25)@64;
assume src0 = lo0 + hi0 * (2**25) && true;

(* construct the multilimb of src1 in boolean and introduce the corresponding algebraic equations *)
split hi1 lo1 src1 25;
spl t lo1 lo1 32;
spl t hi1 hi1 32;
assert true && src1 = (uext lo1 32) + (uext hi1 32) * (2**25)@64;
assume src1 = lo1 + hi1 * (2**25) && true;

(* construct the bit-accessible version of r *)
mulj prod0 lo0 lo1;
mulj prod1 lo0 hi1;
mulj prod2 lo1 hi0;
mulj prod3 hi0 hi1;
add pmid prod1 prod2;
assert true && pmid = prod1 + prod2;
assume pmid = prod1 + prod2 && true;
cast uint128 bit_r prod0;
mulj t pmid (2**25)@uint64;
add bit_r bit_r t;
mulj t prod3 (2**50)@uint64;
add bit_r bit_r t;

assert r = bit_r && true;
assume true && r = bit_r;

(* construct intermediate values for the multilimb *)
spl phi plo prod0 25;
spl phi philo phi 32;

cast uint64 t philo;
add pnewmid pmid t;
assert true && pnewmid = pmid + t;
assume pnewmid = pmid + t && true;

spl phi plo pnewmid 25;
spl phi pnewhilo phi 32;

cast uint64 t pnewhilo;
add pnewhi prod3 t;
assert true && pnewhi = prod3 + t;
assume pnewhi = prod3 + t && true;

(* make sure our construction is the same as the bitfield extraction *)
spl hi lo r 50;
spl hi t hi 64;
assert true && pnewhi = t;

(* construct values for the sticky bit operation *)

(* we construct the value where the 50th bit is the sticky bit *)
spl hi50 lo50 r 50;
spl hi50 t50 hi50 64;
assert true && pnewhi = t50;
not t@uint50 lo50;
adds discard t t 1@uint50;
or t@uint50 t lo50;
mov lo50orsum t;
spl t lo t 49;
cast uint64 t t;
or tsticky50@uint64 t50 t;

(* we construct the value where the 51th bit is the sticky bit *)
spl hi51 lo51 r 51;
spl hi51 t51 hi51 64;
not t@uint51 lo51;
adds discard t t 1@uint51;
or t@uint51 t lo51;
spl t lo t 50;
cast uint64 t t;
or tsticky51@uint64 t51 t;

(* we choose the right value here *)
spl hi lo tsticky50 55;
spl hi lo hi 1;
adds shift_sticky discard lo 1@uint1;
cmov tsticky shift_sticky tsticky51 tsticky50;

assert true && or[tsticky = 0@64, and[(2**54)@64 <= tsticky, tsticky < (2**55)@64]];

(* construct the right mantissa *)

(* round to nearest, to even if tie *)
spl hi lo tsticky 3;
spl b2 b0b1 lo 2;
spl b1 b0 b0b1 1;
or t@uint1 b0 b2;
and t@uint1 b1 t;
cast uint64 t t;
shrs rm64 lo tsticky 2;
add rm64 rm64 t;

assert true && or[rm64 = 0@64, and[(2**52)@64 <= rm64, rm64 <= (2**53)@64]];

(* construct the resulting exponent *)

(* sum up the exponents *)
cast uint32 te0 e0;
cast uint32 te1 e1;
add re te0 te1;

(* subtract 1023 since the exponents are biased *)
subs discard re re 1023@uint32;

(* add 1 due to the conditional shift of sticky bit computation*)
adcs discard re re 0@uint32 shift_sticky;

mov sume@uint32 re;

(* add 1 if the rm = 2**53 *)
spl hi rm52 rm64 52;
spl hi discard hi 1;
cast uint32 hi hi;
adds discard re re hi;

mov rounde@uint32 re;

cast uint12 rounde12 rounde;
assert true && or[and[(2**31)@32 <= rounde, (2**11)@12 <= rounde12], and[0@32 <= rounde, rounde < (2**12)@32]];

(* zeroization *)
adds zflag0 discard rm64 0xffffffffffffffff@uint64;
cmov re zflag0 re 0@uint32;

subs discard t 0@uint32 re;
shrs t discard t 31;
cast uint1 zflag1 t;
cmov rezero zflag1 re 0@uint32;
cmov rmzero zflag1 rm52 0@uint52;

(* saturation *)
subs discard t 2046@uint32 rezero;
shrs t discard t 31;
cast uint1 satflag t;
cmov resat satflag 2046@uint32 rezero;
cmov rmsat satflag 0xfffffffffffff@uint52 rmzero;

(* final exponent *)
spl discard resat11 resat 11;

(* final sign *)
xor rs@uint1 s0 s1;

mov mr rmsat;
mov er resat11;

join res resat11 rmsat;
join res rs res;

assert true && or[and[resat11 = 0@11, rmsat = 0@52], and[0@11 < resat11, resat11 < 2047@11]];
{ 
    true 
        && 
    or[    
    and[
        or[ 1022@11 < er, and[1022@11 = er, 1865452045155277@52 <= mr ] ], 
        or[ 1037@11 > er, and[1037@11 = er, 1865452045155277@52 >= mr ] ] 
    ],
        and[0@11 = er, 0@52 = mr]
    ]
}

